abort task in bdi agent john thangarajah, jame harland rmit univers melbourn, australia {johthan,jah}@cs.rmit.edu.au david morlei, neil york-smith artifici intellig center, sri intern menlo park, ca 94025 u.s.a. {morlei,nysmith}@ai.sri.com abstract intellig agent that ar intend to work in dynam  environ must be abl to gracefulli handl unsuccess task and plan. in addit, such agent should be abl to make ration  decis about an appropri cours of action, which mai includ abort a task or plan, either as a result of the agent"s own  deliber, or potenti at the request of anoth agent. in thi paper we investig the incorpor of abort into a bdi-style  architectur. we discuss some condit under which abort a task or plan is appropri, and how to determin the consequ of such a decis. we augment each plan with an option abort-method, analog to the failur method found in some agent program languag. we provid an oper semant for the execut cycl in the presenc of abort in the abstract agent languag can, which enabl us to specifi a bdi-base execut model without limit our attent to a particular agent system (such as jack, jadex, jason, or spark). a kei technic challeng we address is the presenc of parallel execut thread and of sub-task, which requir the agent to ensur that the abort method for each plan ar carri out in an appropri sequenc. categori and subject descriptor i.2.11 [artifici intellig]: distribut artifici intellig-intellig agent gener term design, reliabl, theori 1. introduct intellig agent gener work in complex, dynam  environ, such as air traffic control or robot navig, in which the success of ani particular action or plan cannot be guarante [13]. accordingli, deal with failur is fundament to agent  program, and is an import element of agent characterist such as robust, flexibl, and persist [21]. in agent architectur inspir by the belief-desir-intent (bdi) model [16], these properti ar often character by the  interact between belief, goal, and plan [2].1 in gener, an agent that wish to achiev a particular set of task will pursu a  number of plan concurr. when failur occur, the choic of plan will be review. thi mai involv seek altern plan for a particular task, re-schedul task to better compli with resourc constraint, drop some task, or some other decis that will increas the likelihood of success [12, 14]. failur can occur for a number of reason, and it is often not possibl to predict these in advanc, either becaus of the complex of the system or  becaus chang in the environ invalid some earlier decis. given thi need for deliber about fail task or plan, failur deliber is commonli built into the agent"s execut cycl. besid deal with failur, an import capabl of an  intellig agent is to be abl to abort a particular task or plan. thi decis mai be due to an intern deliber (such as the agent believ the task can no longer be achiev, or that some  conflict task now ha a higher prioriti) or due to an extern factor (such as anoth agent alter a commit, or a chang in the environ). abort a task or plan is distinct from it failur. failur  reflect an inabl to perform and doe not negat the need to  perform - for exampl, a reason respons to failur mai be to try again. in contrast, abort sai noth about the abil to  perform; it mere elimin the need. failur propag from the bottom up, wherea abort propag from the top down. the potenti for concurr execut sub-plan introduc differ complex for abort and failur. for abort, it mean that multipl concurr sub-plan mai need to be abort as the abort is propag down. for failur, it mean that parallel-sibl plan mai need to be abort as the failur is propag up. there ha been a consider amount of work on plan failur (such as detect and resolv resourc conflict [20, 10]) and most agent system incorpor some notion of failur handl. howev, there ha been rel littl work on the develop of abort techniqu beyond simpl drop of current intend plan and task, which doe not deal with the clean-up requir. as on consequ, most agent system ar quit limit in their treatment of the situat where on branch of a parallel construct 1 on can consid both task to be perform and goal to achiev a certain state of the world. a task can be consid a goal of achiev the state of the task have been perform, and a goal can be consid a task of bring about that state of the world. we adopt the latter view and us task to also refer to goal. 8 978-81-904262-7-5 (rp) c 2007 ifaama fail (common approach includ either let the other branch run to complet unhind or drop it complet). in thi paper we discuss in detail the incorpor of abort  cleanup method into the agent execut cycl, provid a unifi  approach to failur and abort. a kei featur of our procedur-base approach is that we allow each plan to execut some particular code on a failur and on an abort. thi allow a plan to attempt to ensur a stabl, known state, and possibl to recov some resourc and otherwis clean up befor exit. accordingli, a central  technic challeng is to manag the orderli execut of the appropri clean-up code. we show how abort can be smoothli introduc into a bdi-style architectur, and for the first time we give an  oper semant for abort in the abstract agent languag can [23, 17]. thi allow us to specifi an appropri level of detail for the execut model, without focus on the specif construct of ani on agent system such as jack [2], jadex [14], jason [6], or spark [9]. our focu is on a singl agent, complementari to  relat work that consid except handl for singl- and  multiag system (e.g., [22, 5, 6]). thi paper is organ as follow. in section 2 we give an  exampl of the consequ of abort a task, and in section 3 we discuss some circumst under which abort should occur, and the appropri represent and invoc procedur. in  section 4 we show how we can us can to formal specifi the  behaviour of an abort plan. section 5 discuss relat work, and in section 6 we present our conclus and futur work. 2. motiv exampl alic is a knowledg worker assist by a learn, person  assist agent such as calo [11]. alic plan to attend the ijcai confer later in the year, and her calo agent adopt the task of support meet submiss (sm) to assist her. calo"s plan for an sm task in the case of a confer submiss consist of the follow sub-task: 1. alloc a paper number (apn) to be us for administr purpos in the compani. 2. track write abstract (twa): keep track of alic"s progress in prepar an abstract. 3. appli for clearanc (afc) for public from alic"s  manag base on the abstract and confer detail. 4. track write paper (twp): keep track of alic"s progress in write the paper. 5. handl paper submiss (hp): follow compani intern procedur for submit a paper to a confer. these step must be perform in order, with the except of step 3 (afc) and 4 (twp), which mai be perform in parallel. similarli, calo can perform the task appli for clearanc (afc) by a plan consist of: 1. send clearanc request (scr) to alic"s manag. 2. wait for respons (wfr) from the manag. 3. confirm that the respons wa posit, and fail otherwis. now suppos that a chang in circumst caus alic to reconsid her travel plan while she is write the paper. alic will no longer be abl to attend ijcai. she therefor instruct her calo agent to abort the sm task. abort the task impli abort both the sm plan and the afc subplan. abort the first plan requir calo to notifi the paper number registri that the alloc paper number is obsolet, which it can achiev by the cancel paper number (cpn) task.2 abort the second plan requir calo to notifi alic"s manag that alic no longer  requir clearanc for public, which calo can achiev by  invok the cancel clearanc request (ccr) task. we note a number of import observ from the  exampl. first, the decis to abort a particular cours of action can come from the intern deliber of the agent (such as  reason about prioriti in a conflict over resourc), or from extern sourc (such as anoth agent cancel a commit), as in thi exampl. in thi paper we onli touch on the problem of  determin whether a task or plan should be abort, instead concentr on determin the appropri action onc thi decis is made. henc, our object is to determin how to incorpor abort mechan into the standard execut cycl rather than determin what should be abort and when. second, onc the decis is made to abort the attempt to submit a paper, there ar some action the agent should take, such as  cancel the clearanc request. in other word, abort a task is not simpli a matter of drop the task and associ activ plan: there ar some clean up action that mai need to be done. thi is similar to the case for failur, in that there mai also be action to take when a task or plan fail. in both case, note that it is not simpli a matter of the agent undo-ing it action to date; inde, thi mai be neither possibl (sinc the agent act in a situat world and it action chang world state) nor desir (depend on the semant of the task). rather, clean up involv compens via forward recoveri action [3]. third, there is a distinct between abort a task and abort a plan. in the former case, it is clear that all plan be execut to perform the task should be abort; in the latter case, it mai be that there ar better altern to the current plan and on of these should be attempt. henc, plan abort or failur doe not necessarili lead to task abort or failur. fourth, given that task mai contain sub-task, which mai  contain further sub-task, it is necessari for a parent task to wait until it children have finish their abort method. thi is the sourc of on of the technic challeng that we address: determin the precis sequenc of action onc a parent task or plan is abort. 3. abort task and plan as we have allud to, failur and abort ar relat concept. thei both caus the execut of exist plan to ceas and,  consequenti, the agent to reflect over it current task and intent. failur and abort, howev, differ in the wai thei aris. in the case of failur, the trigger to ceas execut of a task or plan come from below, that is, the failur of sub-task or lower-level plan. in the case of abort, the trigger come from abov, that is, the task and the parent plan that initi a plan. in bdi-style system such as jack and spark, an agent"s  domain knowledg includ a pre-defin plan librari of plan claus. each plan claus ha a plan bodi, which is a program (i.e.,  combin of primit action, sub-task, etc.) that can be execut in respons to a task or other event should the plan claus"s context condit be satisfi. the agent select and execut instanc of plan claus to perform it task. there can be more than on  applic plan claus and, in the event that on fail, anoth applic on mai be attempt. plan mai have sub-task that must succe 2 calo need onli drop the twa and twp task to abort them: for the sake of simplic we suppos no explicit clean up of it intern state is necessari. the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) 9 for the plan to succe. in such system, a plan failur occur if on of the action or sub-task within the plan fail. the agent"s action upon plan failur depend on it natur: for exampl, the agent mai declar the task to have fail if on plan ha been tri and result in failur, or it mai retri altern plan and declar (inde, must declar) task failur onli if all possibl altern plan to perform the task have been tri and result in failur. observ that, while task failur can follow from plan failur or a sequenc of plan failur, plan failur need not lead to task failur provid the agent can successfulli complet an altern plan. moreov, task failur can also aris separ from plan failur, if the agent decid to abort the task. our approach associ an abort-method with each plan. thi enabl the programm to specifi dedic compens action accord to how the agent is attempt to perform the task. note that our abort-method can be arbitrari program and so can invok task that mai be perform dynam in the usual bdi fashion, i.e., the clean-up is not limit to execut a predetermin set of action. the question remain which abort-method should be invok, and in what manner. given the complex of agent action space, it is not possibl nor desir to enumer a static set of rule. rather, the agent will invok it abort-method dynam accord to the state of execut and it own intern event. an altern to attach an abort-method to each plan is to attach such method to each atom action. we choos the former becaus: (1) action-level abort-method would incur a greater  overhead, (2) plan ar meant to be design as singl cohes unit and ar the unit of deliber in bdi system, and (3) the  cleanup method for failur in current system ar attach to plan. in order to understand how the agent"s abort process should function, we consid three situat where it is sensibl for an agent to consid abort some of it task and plan: 1. when a task succe or fail becaus of an extern factor other than the agent itself, the plan current execut to  perform the task should be abort. for exampl, suppos  compani polici chang so that employe of alic"s senior automat have clearanc for publish paper. sinc alic now ha clearanc for publish her paper, calo can abort the plan for appli for clearanc. in do so it must invok the abort-method, in thi case thu perform cancel clearanc request.3 2. when two or more sub-program ar execut in parallel, if on fail then the other should be abort, given that the  failur of on branch lead to the failur of the overal task. for exampl, suppos that part-wai through write the paper, alic realiz that there is a fatal flaw in her result, and so notifi calo that she will not be abl to complet the paper by the deadlin. the failur of the track write paper task should caus the appli for clearanc task be execut in parallel to be abort. 3. when an execut event alter the import of an exist task or intent, the agent should deliber over whether the exist plan(s) should continu. for exampl, suppos that alic task calo with a new, high-prioriti task to purchas a replac laptop, but that alic lack enough fund to both purchas the laptop and to attend ijcai. reason over resourc requir [20, 10] will caus the agent to realiz 3 if there is ani differ between how to abort a task that is  extern perform versu how to abort on that is now known to be imposs, the abort-method can detect the circumst and handl the situat as appropri. that it cannot successfulli complet both task. given that the new task ha greater import, a ration agent will evalu it best cours of action and mai decid to  abortor at least suspend - the exist task of submit a paper and intent deriv from it [12]. the oper semant we provid in section 4 for abort task and plan captur the first two situat abov. the third situat involv deliber over the import of a task, which depend on variou factor such as task prioriti. although thi  deliber is beyond the scope of thi paper, it is a complementari topic of our futur work. note that the abov situat appli to achiev goal, for which the task is complet when a particular state of the world is brought about (e.g., ensur we have clearanc). differ form of reason appli to other goal type [4] such as mainten goal [1], where the goal is satisfi by maintain a state of the world for some period of time (e.g., maintain $100 in cash). abort method represent the intent of abort a task or plan is that the task or plan and all it children ceas to execut, and that appropri clean-up method ar perform as requir. in contrast to offlin plan system, bdi agent ar situat: thei perform onlin deliber and their action chang the state of the world. as a result, the effect of mani action cannot be simpli undon. moreov, the undo  process mai caus advers effect. therefor, the clean-up method that we specifi ar forward recoveri procedur that attempt to  ensur a stabl state and that also mai, if possibl, recov resourc. the common plan represent in bdi-style system such as jack and spark includ a failur-method, which is the  design clean-up method invok when the plan fail. to thi, we add the abort-method, which is invok if the plan is to be abort. in our exampl, the abort-method for the plan for support meet submiss consist of invok the sub-task cancel paper  number. the abort-method need not explicitli abort appli for  clearanc, becaus the agent will invok the abort-method for the  subtask appropri, as we outlin below. the assumpt here is that, like the failur-method, the  programm of the agent system ha the opportun to specifi a  sensibl abort-method that take into consider the point in the plan at which the abort is to be execut. for ani plan, the abort-method is option: if no abort-method is specifi, the agent take no  specif action for thi plan. howev, the agent"s default behaviour rule still appli, for exampl, whether to retri an altern plan for the parent task. note that an explicit represent of the clean-up method for task is not requir, sinc task ar perform by execut some plan or plan. henc, abort a task mean abort the current plan that is execut to perform that task, as we next describ. abort method invoc we now inform lai out the agent"s action upon abort plan and task. when a plan p is abort: 1. abort each sub-task that is an activ child of p. an activ child is on that wa trigger by p and is current in  execut. 2. when there ar no more activ children, invok the abort method of plan p. 3. indic a plan failur to tp , the parent task of p. we note here that if the parent task tp is not to be abort then the agent mai choos anoth applic plan to satisfi tp . 10 the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) when a task (or sub-task) t is abort: 1. abort the current activ plan to satisfi t (if ani). 2. when there ar no more activ child process, drop the task. the agent thu no longer pursu t. 3. note here that when the current activ plan for perform t is abort, no other applic plan to perform t should be tri as it is the task that is to be abort. in order to prevent infinit cascad clean-up effort, we  assum that abort-method will never be abort nor fail. in realiti, howev, an abort-method mai fail. in thi case, lack a more sophist handl mechan, the agent simpli stop  execut the fail abort-method with no further deliber. the  assumpt we make is thu not a reflect of the full complex of realiti, but on that is pragmat in term of the agent  execut cycl; the approach to failur-handl of [21] make the same assumpt. in system such as spark, the programm can  specifi an altern behaviour for a fail failur- or abort-method by mean of meta-level procedur. we also assum that failur- and abort-method termin in finit time. 4. oper semant we provid the semant for the task and plan failur and  abort process outlin abov. we us the can languag initi defin in [23] and later extend as canplan in [17] to includ a plan compon and then as canplan2 in [18] to improv the goal adopt and drop mechan. the extens also simplifi the semant in the earlier work. we us some of these simplif for provid a brief summari of the can languag in section 4.1. follow a present of the oper  semant of our approach in section 4.2, in section 4.3 we provid a work exampl to clarifi the semant that we present. 4.1 can languag can is a high-level agent languag, in a spirit similar to that of agentspeak [15] and kinni"s Ψ [7], both of which attempt to extract the essenc of a class of implement bdi agent  system. can provid an explicit goal construct that captur both the declar and procedur aspect of a goal. goal ar  persist in can in that, when a plan fail, anoth applic plan is attempt. thi equat to the default failur handl mechan typic found in implement bdi system such as jack [2]. in practic system, task ar typic translat into event that trigger the execut of some plan. thi is also true in the can languag, but, in order to maintain the persist of goal, a goal construct is introduc. thi is denot by goal ` φs, p, φf ´ , where φs is the success condit that determin when the goal is  consid achiev, φf is a fail condit under which it is consid the goal is no longer achiev or relev, and p is a program for achiev the goal, which will be abort onc φs or φf becom true. an agent"s behavior is specifi by a plan librari, denot by Π, that consist of a collect of plan claus of the form e : c ← p, where e is an event, c is a context condit (a logic formula over the agent"s belief that must be true in order for the plan to be applic)4 and p is the plan bodi. the plan bodi is a program that is defin recurs as follow: p ::= act | +b | −b | ?φ | !e | p1; p2 | p1 p2 | goal ` φs, p1, φf ´ | p1 p2 | {ψ1 : p1, . . . , ψn : pn} | nil 4 an omit c is equival to true. Δ = {ψiθ : piθ | e : ψi ← pi ∈ Π ∧ θ = mgu(e, e )} b, !e −→ b, Δ event ψi : pi ∈ Δ b |= ψi b, Δ −→ b, pi Δ \ {ψi : pi} select b, p1 −→ b, (p1 p2) −→ b, p2 fail b, p1 −→ b , p1 b, (p1; p2) −→ b , (p ; p2) sequenc b, p1 −→ b , p b, (p1 p2) −→ b , (p p2) parallel1 b, p2 −→ b , p b, (p1 p2) −→ b , (p p1) parallel2 figur 1: oper rule of can. where p1, . . . , pn ar themselv program, act is a primit  action that is not further specifi, and +b and −b ar oper to add and delet belief. the belief base contain ground belief atom in the form of first-order relat but could be orthogon extend to other logic. it is assum that well-defin oper ar provid to check whether a condit follow from a belief set (b |= c), to add a belief to a belief set (b ∪ {b}), and to delet a belief from a belief set (b \ {b}). ?φ is a test for condit φ, and !e5 is an event6 that is post from within the program. the compound construct ar sequenc (p1; p2), parallel execut (p1 p2), and goal (goal ` φs, p, φf ´ ). the abov defin the user languag. in addit, a set of  auxiliari compound form ar us intern when assign  semant to construct. nil is the basic (termin) program. when an event match a set of plan claus these ar collect into a set of guard altern ( c1 : p1, . . . , cn : pn ). the other auxiliari compound form, , is a choic oper dual to sequenc: p1 p2 execut p1 and then execut p2 onli if p1 fail. a summari of the oper semant for can in line with [23] and follow some of the simplif of [17] is as follow. a basic configur s = b, g, Γ consist of the current belief base b of the agent, the current set of goal g be pursu (i.e., set of formula), and the current program p be execut (i.e., the current intent). a transit s0 −→ s1 specifi that execut s0 for a singl step yield configur s1. s0 −→∗ sn is the usual reflex transit closur of −→: sn is the result of on or more  singlestep transit. a deriv rule s −→ sr s −→ sr consist of a (possibl empti) set of premis, which ar transit togeth with some auxiliari condit (numer), and a singl transit conclus deriv from these premis (denomin). figur 1 give some of the oper rule. the event rule handl task event by collect all relev plan claus for the event in question: for each plan claus e : ψi ← pi, if there is a most gener unifi, θ = mgu(e, e ) of e and the event in 5 where it is obviou that e is an event we will sometim exclud the exclam mark for readabl. 6 typic an achiev goal. the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) 11 b |= φs b, goal ` φs, p, φf ´ −→ b, true gs b |= φf b, goal ` φs, p, φf ´ −→ b, fail gf p = goal ` φs, p , φf ´ p = p1 £ p2 b |= φs ∨ φf b, p −→ b, goal ` φs, p £ p , φf ´ gi p = p1 £ p2 b |= φs ∨ φf b, p1 −→ b , p b, goal ` φs, p, φf ´ −→ b , goal ` φs, p £ p2, φf ´ gs p = p1 £ p2 b |= φs ∨ φf p1 ∈ {true, fail} b, goal ` φs, p, φf ´ −→ b, goal ` φs, p2 £ p2, φf ´ gr figur 2: rule for goal in can. question, then the rule construct a guard altern ψiθ : piθ. the select rule then select on applic plan bodi from a set of (remain) relev altern: program p Δ state that program p should be tri first, fall back to the remain  altern, Δ \ p, if necessari. thi rule and the fail rule togeth ar us for failur handl: if the current program pi from a plan claus for a task fail, rule fail is appli first, and then if possibl, rule select will choos anoth applic altern for the task if on exist. rule sequenc handl sequenc of program in the usual wai. rule parallel1 and parallel2 defin the possibl interleav when execut two program in parallel. figur 2 give simplifi rule for deal with goal, in line with those present in [17]. the first rule state that a goal succe when φs becom true; the second rule state that a goal fail when φf becom true. the third rule gi initi the execut of a goal-program by updat the goal base and set the program in the goal to p £ p; the first p is to be execut and the second p is us to keep track of the origin program for the goal. the fourth rule gs execut a singl step of the goal-program. the final rule gr restart the origin program (encod as p2 of pair p1 £ p2) whenev the current program is finish but the desir and still possibl goal ha not yet been achiev. 4.2 abort intent and handl failur we next introduc the abil to specifi handler program, in the form of failur- and abort-method, that deal with the clean-up  requir when a given program respect fail or is abort. we do not associ failur- and abort- method with plan claus or with task (event), but rather we introduc a new program construct that specifi failur- and abort- method for an arbitrari program. the fab(p, pf , pa) construct execut the program p. should p fail, it execut the failur handl program pf ; should p need to be abort, it execut the abort handl program pa. thu to add failur- and abort- method pf and pa to a plan claus e : c ← p, we write e : c ← fab(p, pf , pa). with the introduct of the abil to abort program, we  modifi the parallel construct to allow the failur of on branch to abort the other. we must take into consider the possibl exist of abort-method in the abort branch. similarli, with the goal  construct we can no longer complet abandon the program the goal contain as soon as the success or failur condit hold; we must now take into consider the exist of ani abort-method  applic to the program. we provid the semant of an augment agent languag  contain the fab construct by defin a sourc transform,  similar to macro-expans, that map a plan librari contain the fab(p, pf , pa) construct into (almost) standard can. the on non-standard extens to can is a wait-until-condit construct. we explain thi simpl modif of the parallel construct below when we come to translat of the goal construct. first we  describ the gener natur of the sourc transform, which prove to be quit simpl for most of the languag construct, and then we concentr on the three more complex case: the fab, parallel, and goal construct. a kei issu is that the fab construct mai be nest, either  directli or indirectli. let us call each instanti of the construct at execut time a possibl abort point (pap). where these construct ar nest, it is import that befor the failur- or abort-method of a parent pap is execut, the failur- or abort-method program of the children pap ar execut first, as describ earlier in  section 3. the need to coordin the execut of the abort-method of nest pap requir that there be some wai to identifi the  parent and children of a particular pap. we achiev thi as part of the sourc transform by explicitli keep track of the context of execut as an extra paramet on the event and an extra variabl within each plan bodi.7 the sourc transform replac each plan claus of the form e : c ← p with a plan claus e(v) : c ← μv(p) where v is a free variabl, not previous present in the plan claus. thi variabl is us to keep track of the context of execut. the valu of the context variabl is a list of identifi, where each new pap is repres by prepend a new identifi to the context. for exampl, if the identifi ar integ, the context of on pap mai be repres by a list [42, 1] and the context introduc by a new pap mai be repres by [52, 42, 1]. we will refer to pap by the context rather than by the new identifi ad, e.g., by [51, 42, 1] not 51. thi enabl us to equat the ancestor relationship between pap with the list suffix relationship on the relev context, i.e., v is an ancestor of v if and onli if v is a suffix of v . for most can construct, the context variabl is unus or pass unchang: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(p1; p2) = μv(p1); μv(p2) μv(p1 p2) = μv(p1) μv(p2) μv( ψ1 : p1, . . . , ψn : pn ) = ψ1 : μv(p1), . . . , ψn : μv(pn) it remain to specifi the transform μv(·) in three case: the fab, parallel, and goal construct. these ar more complex in that the transform sourc need to creat a new pap identifi dynam, for us as a new context within the construct, and to keep track of when the pap is activ (i.e., current in execut) by ad and remov belief about the context. let us introduc the primit action prependid(v, v ) that  creat a new pap identifi and prepend it to list v give list v . we also introduc the follow predic: • a(v) - the pap v is current activ. • abort(v) - the pap v should be abort (after abort all of it descend). 7 an altern would be to us meta-level predic that reflect the current state of the intent structur. 12 the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) • f(v) - the program of pap v ha fail. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v  ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v .(a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v ha no activ children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; howev, we need to wait until no children of v ar activ. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v ha no activ children. first let us consid the case of the fab construct. the idea is that, whenev a new pap occur, the prependid(v, v ) action is us to creat a new pap identifi list v from the exist list v. we then add the belief that v is the activ context, i.e., +a(v ), and start process the program within the pap us v instead of v as the context. we need to make sure that we retract the belief that v is activ at the end, i.e., −a(v ). we us the goal construct to allow us to drop the execut of a program within a pap v when it is necessari to abort. while execut the program p, we know that we need to drop p and  invok it abort-method if some ancestor of p ha been told to abort. thi is repres by the predic sa(v ) be true. howev, we need to make sure that we do thi onli after everi child pap ha had the chanc to invok it abort-method and all these abort-method have complet: if we drop the program too soon, then execut of the abort-method of the children will also be drop. therefor, the condit we actual us in the goal construct to test when to drop the program is san(v ). thi condit reli on the fact that as the children pap complet, thei remov the relev a fact. our us of the goal construct is for it abil to drop the  execut of a program when condit ar met. to leav asid the  repeat execut until a condit is met aspect, we must ensur that the success or failur condit of the construct is satisfi onc the execut of the program succe or fail. we make sure of thi by retract the fact a(v ) on success and assert the fact f(v ) on failur, and by have the appropri success and failur condit on the goal. henc, if the goal construct fail, then the program either wa abort or it fail. we invok the relev failur- or abort- method, retract the a(v ) fact, and then fail. put all thi togeth, we formal defin μv(fab(p, pa, pf )) to be the follow, where v is a new variabl distinct from ani other in the agent"s plan librari: prependid(v, v ); +a(v ); goal ( ¬a(v ), (μv (p); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(pa)) μv(pf )); −a(v ); ?fals) second, we must transform the parallel oper to ensur that the failur of on branch safe abort the other. here we construct two new context, v and v , from the exist context v. if on branch fail, it must abort the other branch. at the end, if either branch wa abort, then we must fail. let v and v be new variabl distinct from ani other in the agent"s plan librari. we defin μv(p1 p2) to be: prependid(v, v ); prependid(v, v ); +a(v ); +a(v ); ( goal (¬a(v ), (μv (p1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) goal (¬a(v ), (μv (p2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) final, we need to modifi occurr of the goal construct in two wai: first, to make sure that the abort handl method ar not bypass when the success or failur condit ar satisfi, and second, to trigger the abort of the contain program when either the success or failur condit ar satisfi. to transform the goal construct we need to extend standard can with a wait-until-condit construct. the construct φ : p doe not execut p until φ becom true. we augment the can languag with the follow rule for the guard oper ‘:": b |= φ b, g, (φ : p −→ b, g, p :true b |= φ b, g, (φ : p) −→ b, g, (φ : p) :fals in order to specifi μv(goal ` φs, p, φf ´ ), we gener a new pap and execut the program within the goal construct in thi new  context. we must ensur that belief a(v ) is remov whether the goal succe or fail. we shift the success and failur condit of the goal construct into a parallel branch us the wait-until-condit construct, and modifi the goal to us the should abort now  condit san(v ) as the success condit. the wait branch will trigger the abort of the program should either the success or failur condit be met. to avoid ani problem with termin the wait condit, we also end the wait if the pap is no longer activ. let v be a new variabl distinct from ani other in the agent"s plan librari. we defin μv(goal ` φs, p, φf ´ ) to be: prependid(v, v ); +a(v ); ( goal ( san(v ), μv (p), fals) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) the program p will be repeatedli execut until san(v )  becom true. there ar two wai thi can occur. first, if either the success condit φs or the failur condit φf becom true, then the second branch of the parallel construct execut. thi caus abort(v ) to becom true, and, after the descend pap"  abortmethod ar execut, san(v ) becom true. in thi case, p is now drop, the a(v ) is remov, and the entir construct  succe or fail base on φs. the second wai for san(v ) to becom true is if v or on of it ancestor is abort. in thi case, onc the descend pap" abort-method ar execut, san(v ) becom true, p is drop, the a(v ) belief is remov (allow the  second parallel branch to execut, vacuous instruct v to abort), and the first parallel branch fail (assum φs is fals). 4.3 work exampl let us look at translat of the ijcai submiss exampl of section 2. we will express task by event, for exampl, the task alloc a paper number we express as the event apn. let the output of the appli for clearanc task be y or n, indic the approv or not of alic"s manag, respect. then we have (at least) the follow two plan claus in can, for the support meet submiss and appli for clearanc task, respect: sm(m) : isconf(m) ← fab(!apn; !twa; (!afc !twp); !hp, !cpn, !cpn) afc : true ← fab(!scr; !wfr(r); ?r = y, nil, !ccr) note that support meet submiss ha a paramet m, the meet of interest (ijcai, in our exampl), while appli for  clearanc ha no paramet. the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) 13 let us look first at the translat of the second plan claus, for afc, sinc it is the simpler of the two. let v and v denot new variabl. then we have as the translat plan claus: afc(v ) : true ← prependid(v , v ); +a(v ); goal ( ¬a(v ), (!scr(v ); !wfr(r, v ); ?r = y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !ccr(v )) nil); −a(v ); ?fals) we can see that an extra context paramet ha been ad to each task and that the old plan bodi now appear insid a goal construct. should the old plan bodi succe, belief a(v ) is  retract, caus the goal to succe. if the old plan bodi fail, or if the task is to be abort, the goal construct fail. thi is follow by the execut of ccr (in the case of an abort), the retract of a(v ), and failur. the translat of the first plan claus, for sm, is more  complex, becaus of the parallel construct that introduc nest pap: sm(m, v) : isconf(m) ← prependid(v, v ); +a(v ); goal ( ¬a(v ), ((!apn(v ); !twa(v ); prependid(v , v ); prependid(v , v ); +a(v ); +a(v ); ( goal ( ¬a(v ), (!afc(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) goal ( ¬a(v ), (!twp(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !hp(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !cpn(v)) !cpn(v)); −a(v ); ?fals) here we can see that if the task !twp(v ) fail then f(v ) will be assert, fail the goal construct that contain it, and lead to abort(v ) be assert. if the !wfr(r, v ) task in the expans of !afc(v ) is still execut and ha no  activ child pap, then sa(v ) and sa(v ) will be true; howev, onli san(v ) and not san(v ) will be true. thi set of  condit will caus the goal construct in the first plan claus to fail, drop execut of !wfr(r, v ). the task !ccr(v ) will be execut. onc thi task complet, belief a(v ) is retract, caus san(v ) to becom true, lead to the first goal construct of the second plan claus to fail. while the translat plan claus appear complic, observ that the translat from the initi plan claus is entir  autom, accord to the rule set out in section 4.2. the translat plan claus, with the semant of can augment by our  waituntil-condit construct, thu specifi the oper of the agent to handl both failur and abort for the exampl. 5. relat work plan failur is handl in the extend version of agentspeak found in the jason system [6]. failur clean-up plan ar  trigger from goal delet event −!g. such plan, similar to our failur method, ar design for the agent to effect state chang (act to undo it earlier action) prior to possibl attempt  anoth plan to achiev the fail goal g. given jason"s construct for drop a goal with an indic of whether or not to try an altern plan for it, h¨ubner et al. [6]  provid an inform descript of how a jason agent modifi it  intent structur when a goal failur event occur. in a goal delet plan, the programm can specifi ani undo action and whether to attempt the goal again. if no goal delet plan is provid, jason"s default behaviour is to not reattempt the goal. failur  handl is appli onli to plan trigger by addit of an  achiev or test goal; in particular, goal delet event ar not post for failur of a goal delet plan. further, the inform semant of [6] do not consid parallel sub-goal (i.e., the can construct), sinc such execut is not part of jason"s languag. the implement of h¨ubner et al. [6] requir jason"s intern action. a requir for implement our approach is a  reflect capabl in the bdi agent implement. suitabl  implement of the bdi formal ar jack [2], jadex [14], and spark [9]. all three allow meta level method that ar cu by meta event such as goal adopt or plan failur, and offer  introspect capabl over goal and intent state. such meta level facil ar also requir by the approach of unruh et al. [21], who defin goal-base semant compens for an agent. failur-handl goal ar invok accord to  failurehandl strategi rule, by a dedic agent failur handl  compon (fhc) that track task execut. these goal ar  specifi by the agent programm and attach to task, much like our fab(p, pf , pa) construct associ failur and abort  method with a plan p. note, howev, that in contrast to both [6] and our semant, [21] attach the failur-handl knowledg at the goal, not plan, level. their failur-handl goal mai consist of stabil goal that perform local, immedi clean-up to restor the agent"s state to a known, stabl state, and  compens goal that perform undo action. compens goal ar trigger on abort a goal, and so not necessarili on goal failur (i.e., if the fhc direct the agent to retri the fail goal and the retri is success). the fhc approach is defin at the goal level in order to  facilit abstract specif of failur-handl knowledg; the fhc decid when to address a failur and what to do (i.e., what  failurehandl goal to invok), separ thi knowledg from the how of implement correct action (i.e., what plan to execut to meet the adopt failur-handl goal). thi contrast with  simplist plan-level failur handl in which the what and how ar intermingl in domain task knowledg. while our approach is  defin at the plan level, our extend bdi semant provid for the separ of execut and failur handl. further, the fhc explicitli maintain data structur to track agent execut. we leverag the exist execut structur and self-reflect abil of a bdi agent to accomplish both abort and failur handl without addit overhead. fhc"s failur-handl strategi rule (e.g., whether to retri a fail goal) ar replac by instruct in our pf and pa plan, togeth with meta-level default failur handler accord to the agent"s natur (e.g., blindli commit). the fhc approach is independ of the architectur of the agent itself, in contrast to our work that is dedic to the bdi  formal (although not ti to ani on agent system). thu no formal semant ar develop in [21]; the fhc"s oper is given as 14 the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) a state-base protocol. thi approach, togeth with state  checkpoint, is us for multi-agent system in [22]. the result architectur emb their failur handl approach within a pair process architectur for agent crash recoveri. other work on multi-agent except handl includ aoex"s distribut except handl agent [5], and the similar sentinel of [8]. in both case, failur-handl logic and knowledg ar decoupl from the agent; by contrast, while separ except handl from domain-specif knowledg, unruh et al."s fhc and our approach both retain failur-handl logic within an agent. 6. conclus and futur work the task and plan of an agent mai not successfulli reach  complet, either by the choic of the agent to abort them (perhap at the request of anoth agent to do so), or by unbidden factor that lead to failur. in thi paper we have present a procedur-base approach that incorpor abort task and plan into the  deliber cycl of a bdi-style agent, thu provid a unifi approach to failur and abort. our primari contribut is an analysi of the requir on the oper of the agent for abort task and plan, and a correspond oper semant for abort in the abstract agent languag can. we ar plan to implement an instanc of our approach in the spark agent system [9]; in particular, the work of thi paper will be the basi for spark"s abort handl mechan. we ar also develop an analysi tool for our extend version of can as a basi for experiment. an intellig agent will not onli gracefulli handl unsuccess task and plan, but also will deliber over it cognit attitud to decid it next cours of action. we have assum the default  behaviour of a bdi-style agent, accord to it natur: for instanc, to retri altern to a fail plan until on succe or until no altern plan remain (in which case to fail the task). futur work is to place our approach in servic of more dynam agent reason, such as the introspect that an agent capabl of  reason over task interact effect and resourc requir can accomplish [19, 12]. relat to thi is determin the cost of abort a task or plan, and us thi as an input to the deliber process. thi would in particular influenc the commit the agent ha toward a  particular task: the higher the cost, the greater the commit. our assumpt that abort-method do not fail, as discuss abov, is a pragmat on. howev, thi is an issu worthi of further  explor, either to develop weaker assumpt that ar also  practic, or to analyz condit under which our assumpt is  realist. a further item of interest is extend our approach to failur and abort to mainten goal [1]. for such goal a differ  oper semant for abort is necessari than for achiev goal, to match the differ in semant of the goal themselv. acknowledg we thank lin padgham and the anonym review for their comment. the first author acknowledg the support of the australian research  council and agent orient softwar under grant lp0453486. the work of the two author at sri intern wa support by the defens advanc research project agenc (darpa) under contract no. nbchd030010. ani opinion, find, and conclus or recommend express in thi materi ar those of the author and do not necessarili reflect the view of darpa or the depart of interior-nation busi center. 7. refer [1] l. braubach, a. pokahr, d. moldt, and w. lamersdorf. goal represent for bdi agent system. in proc. of second intl. workshop on program multi-agent system (proma"04), 2004. [2] p. busetta, r. r¨onnquist, a. hodgson, and a. luca. jack intellig agent - compon for intellig agent in java. agentlink new, issu 2, 1999. [3] m. g. chessel, c. vine, d. butler, c. m. ferreira, and p. henderson. extend the concept of transact compens. ibm system journal, 41(4), 2002. [4] m. dastani, m. b. van riemsdijk, and j.-j. c. meyer. goal type in agent program. in proc. of aama"06, 2006. [5] s. entwisl, s. loke, s. krishnaswami, and e. kendal. aoex: an agent-base except handl framework for build reliabl, distribut, open softwar system. in proc. of seventh joint conf. on knowledg-base softwar engin, 2006. [6] j. f. h¨ubner, r. h. bordini, and m. wooldridg. program declar goal us plan pattern. in proc. of 4th intl. workshop on declar agent languag and technolog, 2006. [7] d. kinni. the psi calculu: an algebra agent languag. in proc. of atal"01, 2001. [8] m. klein, j. a. rodr´ıguez-aguilar, and c. dellaroca. us domain-independ except handl servic to enabl robust open multi-agent system: the case of agent death. autonom agent and multi-agent system, 7(1-2):179-189, 2003. [9] d. morlei and k. myer. the spark agent framework. in proc. of aama"04, 2004. [10] d. morlei, k. l. myer, and n. york-smith. continu refin of agent resourc estim. in proc. of aama"06, 2006. [11] k. myer, p. berri, j. blyth, k. conlei, m. gervasio, d. mcguin, d. morlei, a. pfeffer, m. pollack, and m. tamb. an intellig person assist for task and time manag. ai magazin, 28, 2007. to appear. [12] k. l. myer and n. york-smith. a cognit framework for deleg to an assist user agent. in proc. of aaai 2005 fall symposium on mix-initi problem-solv assist, 2005. [13] l. padgham and m. winikoff. develop intellig agent system: a practic guid. john wilei and son, 2004. [14] a. pokahr, l. braubach, and w. lamersdorf. jadex: a bdi reason engin. in r. bordini, m. dastani, j. dix, and a. e. f. seghrouchni, editor, multi-agent program. springer, 2005. [15] a. s. rao. agentspeak(l): bdi agent speak out in a logic comput languag. in proc. of seventh european workshop on model autonom agent in a multi-agent world, 1996. [16] a. s. rao and m. p. georgeff. an abstract architectur for ration agent. in proc. of kr"92, 1992. [17] s. sardi˜na, l. de silva, and l. padgham. hierarch plan in bdi agent program languag: a formal approach. in proc. of aama"06, 2006. [18] s. sardina and l. padgham. goal in the context of bdi plan failur and plan. in proc. of aama"07, 2007. [19] j. thangarajah, l. padgham, and m. winikoff. detect and exploit posit goal interact in intellig agent. in proc. of aama"03, 2003. [20] j. thangarajah, m. winikoff, l. padgham, and k. fischer. avoid resourc conflict in intellig agent. in proc. of ecai-02, 2002. [21] a. unruh, j. bailei, and k. ramamohanarao. a framework for goal-base semant compens in agent system. in proc. of first intl. workshop on safeti and secur in multi-agent system, 2004. [22] a. unruh, h. harjadi, j. bailei, and k. ramamohanarao. semant-compens-base recoveri manag in multi-agent system. in proc. of second ieee symposium on multi-agent secur and surviv (ieee ma&s"05), 2005. [23] m. winikoff, l. padgham, j. harland, and j. thangarajah. declar and procedur goal in intellig agent system. in proc. of kr"02, 2002. the sixth intl. joint conf. on autonom agent and multi-agent system (aama 07) 15 