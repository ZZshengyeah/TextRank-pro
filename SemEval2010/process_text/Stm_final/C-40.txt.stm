edg index in a grid for highli dynam virtual environ∗ beomjoo seo bseo@usc.edu roger zimmermann rzimmerm@imsc.usc.edu comput scienc depart univers of southern california lo angel, ca 90089 abstract newli emerg game-base applic system such as second life1 provid 3d virtual environ where multipl user  interact with each other in real-time. thei ar fill with autonom, mutabl virtual content which is continu augment by the user. to make the system highli scalabl and dynam  extens, thei ar usual built on a client-server base grid subspac divis where the virtual world ar partit into manag sub-world. in each sub-world, the user continu receiv relev geometri updat of move object from remot  connect server and render them accord to her viewpoint, rather than retriev them from a local storag medium. in such system, the determin of the set of object that ar visibl from a user"s viewpoint is on of the primari factor that affect server throughput and scalabl. specif, perform real-time visibl test in extrem dynam virtual environ is a veri challeng task as million of object and sub-million of activ user ar move and interact. we recogn that the  describ challeng ar close relat to a spatial databas problem, and henc we map the move geometri object in the virtual space to a set of multi-dimension object in a spatial databas while model each avatar both as a spatial object and a move queri. unfortun, exist spatial index method ar unsuit for thi kind of new environ. the main goal of thi paper is to present an effici spatial  index structur that minim unexpect object pop and  support highli scalabl real-time visibl determin. we then uncov mani us properti of thi structur and compar the index structur with variou spatial index method in term of queri qualiti, system throughput, and resourc util. we  expect our approach to lai the groundwork for next-gener  virtual framework that mai merg into exist web-base servic in the near futur. categori and subject descriptor: c.2.4 [comput -  commun network]: distribut system - client/server,  distribut applic, distribut databas; i.3.7 [comput  graphic]: three-dimension graphic and realism - virtual realiti gener term: algorithm, design, perform 1. introduct recent, massiv multiplay onlin game (mmog) have been studi as a framework for next-gener virtual  environ. mani mmog applic, howev, still limit themselv to a tradit design approach where their 3d scene complex is carefulli control in advanc to meet real-time render  constraint at the client consol side. to enabl a virtual landscap in next-gener environ that is seamless, endless, and limitless, marshal et al. [1] identifi four new requir2 : dynam extens (a system allow the addit or the chang of compon at run time);  scalabl (although the number of concurr user increas, the  system continu to function effect); interact; and  interoper. in thi paper, we mainli focu on the first two  requir. dynam extens allow regular game-user to deploi their own creat content. thi is a power concept, but unfortun, user-creat content tend to creat imbal among the  exist scene complex, caus system-wide perform problem. full support for dynam extens will, thu, continu to be on of the biggest challeng for game develop. anoth import requir is scalabl. although mmog develop proclaim that their system can support hundr of thousand of concurr user, it usual doe not mean that all the user can interact with each other in the same world. by  carefulli partit the world into multipl sub-world or replic world at geograph dispers locat, massiv number of concurr user can be support. typic, the maximum  number of user in the same world manag by a singl server or a server-cluster is limit to sever thousand, assum a rather stationari world [2, 3]. second life [4] is the first successfulli deploi mmog  system that meet both requir. to mitig the dynam of the game world, where a larg number of autonom object ar  continu move, it partit the space in a grid-like manner and 2 origin, these requir were specifi for their dedic platform. but we acknowledg that these requir ar also valid for new virtual environ. 402 avatar object poppingautonom entiti (a) at time t (b) at time t+Δ figur 1: object pop occur as a user move forward (screenshot from second life) where Δ = 2 second. emploi a client/server base 3d object stream model [5]. in thi model, a server continu transmit both updat event and geometri data to everi connect user. as a result, thi  extens game environ ha acceler the deploy of  usercr content and provid user with unlimit freedom to  pursu a navig experi in it space. on of the main oper in mmog applic that stream 3d object is to accur calcul all object that ar visibl to a user. the tradit visibl determin approach, howev, ha an object pop problem. for exampl, a hous outsid a user"s visibl rang is not drawn at time t, illustr in figur 1(a). as the user move forward, the hous will suddenli appear at time (t + Δ) as shown in figur 1(b). if Δ is small, or the hous is larg enough to collid with the user, it will disrupt the user"s  navig experi. the visibl calcul for each user not onli need to be  accur, but also fast. thi challeng is illustr by the fact that the maximum number of concurr user per server of second life is still an order of magnitud smaller than for stationari world. to address these challeng, we propos a method that identifi the most relev visibl object from a given geometri databas (view model) and then put forth a fast index method that  comput the visibl object for each user (spatial index). our two novel method repres the main contribut of thi work. the organ of thi paper is as follow. section 2 present relat work. section 3 describ our new view method. in  section 4, we present assumpt on our target applic and  introduc a new spatial index method design to support real-time visibl comput. we also discuss it optim issu. section 5 report on the quantit analysi and section 6 present preliminari result of our simul base experi. final, we conclud and address futur research direct in section 7. 2. relat work visibl determin ha been wide explor in the field of 3d graphic. variou local render algorithm have been  propos to elimin unnecessari object befor render or at ani stage in the render pipelin. view-frustum cull, back-face cull, and occlus cull ar some of the well-known  visibl cull techniqu [6]. howev, these algorithm assum that all the candid visibl object have been store local. if the target object ar store on remot server, the client  receiv the geometri item that ar necessari for render from the server databas. teller et al. describ a geometri data schedul algorithm that maxim the qualiti of the frame rate over time in remot walkthrough of complex 3d scene from a user"s  navig path [5]. funkhous et al. show that multi-resolut represent, such as level of detail (lod), can be us to improv render frame rate and memori util dure  interact visual [7]. howev, these onlin optim  algorithm fail to address perform issu at the server in highli crowd environ. on the other hand, our visibl  comput model, a repres of thi categori, is base on differ assumpt on the data represent of virtual entiti. in the graphic area, there ha been littl work on support real-time visibl comput for a massiv number of move object and user. here we recogn that such graphic relat issu have a veri close similar to spatial databas problem. recent, a number of public have address the  scalabl issu on how to support massiv number of object and queri in highli dynam environ. to support frequent updat, two partit polici have been studi in depth: (1) r-tree base spatial index, and (2) grid-base spatial index. the r-tree is a well-known spatial index structur that allow overlap  between the region in differ branch which ar repres by minimum bound rectangl (mbr). the grid-base  partit model is a special case of fix partit. recent, it ha been re-discov sinc it can be effici in highli dynam  environ. mani studi have report that the r-tree and it variant (r+  tree, r∗ -tree) suffer from unaccept perform degrad in a highli dynam environ, primarili due to the comput complex of the split algorithm [8, 9, 10, 11, 12]. a bottom-up updat strategi propos for r-tree [9] optim updat  oper of the index while maintain a top down queri process mechan. instead of travers a tree from the root node for  frequent updat request (top-down approach), it directli access the leaf node of the object to be updat via an object hash tabl. q-index [13, 11] is on of the earlier work that re-discov the us of grid-base space partit for emerg  move object environ. in contrast to tradit spatial index method that construct an index on the move object, it build an index on the continu rang queri, assum that the queri move infrequ while the object move freeli. the basic idea of the q+rtree [14] is to separ index structur for  quasistationari object and move object: fast-move object ar  index in a quadtre and quasi-stationari object ar store in an r∗ -tree. sina [10] wa propos to provid effici queri  evalu for ani combin of stationari/move object and  stationari/move queri. specif, thi approach onli detect newli discov (posit) or no longer relev (neg) object updat effici. unlik other spatial index method that  focu on reduc the queri evalu cost, hu et al. [12] propos a gener framework that minim the commun cost for locat updat by maintain a rectangular area call a safe  region around move object. as long as ani object resid in thi region, all the queri result ar guarante to be valid in the  system. if object move out of their region, locat updat request should be deliv to the databas server and the affect queri ar re-evalu on the fly. our index method is veri similar to the abov approach. the major differ is that we ar more concentr on real-time visibl determin while other  assum loos time constraint. 3. object-initi view model in thi section we illustr how the object pop problem can be associ with a typic view decis model. we then propos our own model, and final we discuss it strength and limit. to begin with, we defin the terminolog commonli us throughout thi paper. entiti in a virtual space can be categor into three type 403 base on their role - autonom entiti, spectat entiti, and avatar. the term autonom entiti refer to an ordinari move or stationari geometr object that can be visibl to other entiti. the spectat entiti correspond to a player"s viewpoint, but is  invis to other entiti. it ha no shape and is repres onli by a point locat. it is design to allow a game particip to see from a third-person viewpoint. it function similar to a  camera control in the 3d graphic field. it also ha a higher degre of mobil than other entiti. the avatar repres a normal game user who can freeli navig in the space and interact with other entiti. it possess both featur: it own viewpoint and  visibl. for the remaind we us the term object entiti to refer to an autonom entiti or an avatar while we us user entiti to denot an avatar or a spectat entiti. the visibl rang of an entiti refer to the spatial extent within which ani other entiti can recogn it exist. it is base on the assumpt that there alwai exist an optim visibl distanc between a user and an object at ani given time and everi user  possess equal visibl. thu, the user and the object, onli when their current distanc is smaller than or equal to the optim, can see each other. to specifi the visibl rang, much literatur in the graphic area [5, 6] us a circular area of interest (aoi) whose center is the locat of an entiti. it omnidirect natur  allow rapid direct chang without ani displai disrupt at the peripheri of the viewabl area. howev, we emploi a  squareshap aoi at the expens of accuraci becaus the squar-shape spatial extens is veri simpl and effici to be index in a grid partit world. the tradit view model, which we call user-initi view model, assum that a user entiti ha an aoi while an object entiti doe not. as the user navig, she continu search for all the entiti within her aoi. due to it simpl design and it low  index overhead, mani locat base servic (lbss) and game applic us thi model. howev, the user-initi model ha a seriou object pop problem dure navig. recal, as shown in figur 1, that the hous that will have appear at time t + Δ doe not appear at time t becaus the user cannot recogn object that ar outsid of her aoi at time t. in fact, it turn out that the side length of her aoi wa smaller than the optim distanc between the user and the hous at the time t. therefor, there is no other wai but to increas the visibl rang of the user in thi model to make such an  experi unlik. a larg aoi, howev, mai lead to a signific system degrad. to overcom the object pop problem, we propos a new view model which we call object-initi view model. all object entiti have their own aoi center at their current locat while all spectat entiti have no aoi. everi user entiti recogn the object whose aoi cover it point locat. the main strength of the new model ar that (1) it ha no object pop problem as long as the underli system can manag the optim visibl rang of all object entiti correctli and that (2) the content creator can produc an enrich express of variou behavior and tempor chang. a huge object mai have a  farther visibl rang than a small on; an object ha a broader visibl rang dure dai-time than at night; even dure the night the  visibl rang of an object that own a light sourc will have a much wider visibl area than a non-illumin object; if an object is  locat insid a build, it visibl rang would be constrain by the surround structur. on of the potenti argument against the object-initi view is that index of the spatial extens of an object is too complex to be practic, compar with the user-initi view. we agre e2 e1 a s client s client a sub-world server figur 2: target system in a 4 × 4 grid partit. that exist spatial index method ar ineffici in  support our view model. to refut thi argument, we propos a novel spatial index solut detail in section 4.4. our spatial  index solut offer a veri promis perform even with a larg number of mobil entiti and visibl calcul in real-time. for the rest of the paper our design scope is limit to a 2d space, although our applic is target for 3d environ3 . note that our view model is not intend to rival a sophist visibl decis algorithm such as visibl cull [6], but to  effici filter out unnecessari entiti that do not contribut to the final imag. in section 6.1 we evalu both model through  quantit measur such as the degre of express and the qualiti of the two view model and we discuss simul result. 4. design of edg index in section 4.1 we introduc our target applic model. next, section 4.2 present an abstract of our node and edg structur whose detail index and cell evalu method ar explain later in section 4.3 and 4.4. sever optim issu for edg index follow in section 4.5. 4.1 target applic our target applic assum both 3d object stream and sub-world host. the sub-world host is a collabor  virtual environ where everi server host on sub-world, thu construct a singl world. second life is the classic exampl of such an approach. a virtual space is partit into equal-size sub-world. the sampl sub-world separ with bold-dash line in figur 2 contain four virtual entiti: two autonom entiti (e1, e2); on spectat entiti s; and on avatar a. as mention in  section 3, all object entiti (e1, e2, a) have their own squar-shape aoi. two user entiti (s, a) ar associ with individu client machin, (client s and client a in the figur). the spatial  condit that the point locat of s resid insid the aoi of e2 can be symbol as s.p ∈ e2.r. everi sub-world is manag by it dedic server machin. each server index all the entiti, deliv ani new event (i.e., a new user enter into the sub-world or an object move from on place to anoth) to client, and resolv ani inconsist among the entiti. for effici manag of move entiti, a server further divid it sub-world into smaller partit, call grid cell. figur 2 show the 4 × 4 grid enclos by the dash line. instead of index the object entiti with a user entiti structur, our system index their visibl region on the grid cell. retriev of the index object for a given user includ the search and  de3 a better index method for a 3d space is work in progress. 404 token: it(e1) it(e2) it(a) it(s) token: at(e1) dt(e1) at(e2) dt(e2) at(a) dt(a) it(s) (a) node index (b) edg index (c) edg index with row-wise cell evalu figur 3: illustr of differ data structur for node index and edg index for the sampl space in figur 2. there ar three object entiti, {e1, e2, a}, and two user entiti, {s, a} in the world. liveri of the indic store on the cell it is locat in. thi retriev process is interchang call a user (or queri) evalu. our applic onli consid the effici index of virtual entiti and the search for the most relev entiti - that is, how mani entiti per sub-world ar index and how quickli index updat ar recogn and retriev. effici deliveri of retriev real geometri data is out of the scope of thi paper. 4.2 abstract we defin a token as an abstract of a virtual entiti that  satisfi a specif spatial relationship with a given cell. in our  applic, we us three type of token: inclus token (it) indic that it entiti overlap with or is cover by the given cell. appear token (at) denot that it entiti is an it for the given cell, but not for the previous adjac cell. disappear token (dt) is the opposit of at, mean that while it entiti doe not satisfi the it relationship with the given cell, it doe so with the previous adjac cell. we also defin two data structur for store and retriev the token: a node and an edg. a node is a data structur that store it of a cell. thu, the node for cell i is defin as a set of it entiti and formal express as ni = {o|o.r∩i.r = ∅}, where r is either an aoi or a cell region. an edg is anoth data structur for two adjac cell that store their at or dt. if the edg onli store the at entiti, it is term an appear edg (ae); otherwis, if it store dt, it is term a disappear edg (de). the ae for two adjac cell i and j is defin as a set of at and express as e+(i, j) = nj − (ni ∩ nj ) (1) where ni and nj ar the node structur for the cell i and j. the de for two adjac cell i, j is defin as a set of dt, satisfi: e−(i, j) = ni − (ni ∩ nj ) (2) in a 2d map, depend on the adjac relationship between two neighbor cell, edg ar further classifi as either  rowwis, if two neighbor ar adjac horizont (er ), or  columnwis, if thei ar adjac vertic (ec ). consequ, edg ar of four differ type, accord to their token type and adjac: er +(i, j), er −(i, j), ec +(i, j), and ec −(i, j). 4.3 node index grid partit is a popular space subdivis method that ha recent gain popular for index move entiti in highli dynam virtual environ [12, 8, 13, 10]. to highlight the  differ to our newli propos method, we term all exist grid partit-base index method node index. node  index partit the space into equi-size subspac (grid cell),  index entiti on each cell, and search for entiti that satisfi a spatial condit with a given queri. in mani lb applic, node index maintain a node  structur per cell and store an index of entiti whose spatial extent is a point locat. for a given rang queri, a search is perform from the node structur of the cell whose region intersect with the spatial extent of the rang queri. due to the us of a simpl point geometri for entiti, thi allow for lightweight index  updat. much of the exist work fall into thi categori. howev, if the spatial extent of an entiti is a complex geometri such as rectangl, node index will suffer from signific system degrad due to expens updat overhead. for exampl, a  singl movement of an entiti whose spatial extent overlap with 100 grid cell requir 100 token delet and 100 token insert, in the worst case. on of the popular node index method, queri index, ha been report to have such perform degrad dure the updat of rectangl-shape rang queri [13]. for the sampl space shown in figur 2, the concept of node index is illustr in figur 3(a). everi cell store it entiti that intersect with it region. queri process for the spectat s mean to search the node structur whose cell region intersect with s. in figur 3(a), e2 is index on the same cell, thu be deliv to the client s after the queri evalu. 4.4 edg index our new index method, edg index, is design to  provid an effici index method for the specif spatial extens (squar) of the entiti in a grid. it featur ar (1) an edg  structur and (2) period entiti updat and cell evalu. 4.4.1 idea edg structur the main characterist of our approach is that it maintain edg structur instead of us node structur. with thi approach, redund it between two adjac cell (ni ∩nj ) ar elimin. in a 2d m × m grid map, each cell i is surround by four neighbor cell (i− 1), (i+ 1), (i− m), (i+ m) (except for the 405 outermost cell) and eight differ edg structur. if the first two neighbor cell ar horizont adjac to i and the last two cell (i−m), (i+m) ar vertic nearbi, the eight edg structur ar ec +(i−m, i), ec −(i−m, i), er +(i−1, i), er −(i−1, i), er +(i, i+ 1), er −(i, i + 1), ec +(i, i + m), and ec −(i, i + m). figur 3(b) illustr how edg structur ar construct from node structur, us equat 1 and 2. invers, the cell  evalu process with edg index deriv node structur from the edg structur. if ani node structur and all the edg structur ar known a priori, we can deriv all the node structur as defin by lemma 1. the proof of lemma 1 is trivial as it is easili induc from equat 1 and 2. lemma 1. nj , a set of it of a given cell j can be deriv from a set of it of it neighbor cell i, ni and it edg e+(i, j) − e−(i, j): nj = ni + e+(i, j) − e−(i, j) row-wise and column-wise edg structur, howev, captur some redund inform. thu, na¨ıve edg index store more token than node index - the total number of edg token shown in figur 3(b) is 35 (17 at + 17 dt + 1 it); for node  index in figur 3(a) the number is 25. to reduc such redund, a subsequ two-step algorithm can be appli to the origin edg index. period entiti updat and cell evalu mani object ar continu move and henc index structur must be regularli updat. gener, thi is done through a  twostep algorithm [13] that work as follow. the algorithm begin by updat all the correspond indic of newli move entiti (the entiti updat step) and then comput the node structur of everi cell (the cell evalu step). after on cell evalu, the index user entiti ar retriev and the comput node structur is deliv for everi client that is associ with a user. after all the cell ar evalu, the algorithm start over. the two-step algorithm can also be us for our edg index by updat the edg structur of the entiti that move dure the previou time period and by appli lemma 1 dure the cell evalu. in addit to thi adapt, the lemma also reveal anoth import properti of cell evalu: either row edg or column edg ar enough to obtain all the node structur. let us assum that the system maintain the row-wise edg. the leftmost node structur ar assum to be obtain in  advanc. onc we know the node structur of the leftmost cell per row, we can comput that of it right-hand cell from the leftmost node structur and the row-wise edg. we repeat thi comput until we reach the rightmost cell. henc, without ani column-wise edg we can obtain all the node structur successfulli. as a  result, we reduc the complex of the index construct and updat by a factor of two. figur 3(c) illustr the concept of our row-wise edg index method. the total number of token is reduc to 17 (8 at + 8 dt + 1 it). the detail analysi of it index complex is present in section 5. 4.4.2 anoth exampl figur 4 illustr how to construct edg structur from two nearbi cell. in the figur, two row-wise adjac cell 3 and 4 have two row-wise edg transit between them, e+(3, 4), e−(3, 4); two point entiti p1, p2; and two polygon entiti r1, r2. as shown in the figur, n3 index {p2, r1, r2} and n4  maintain the indic of {p1, r2}. e+(3, 4) is obtain from  equat 1: n4 − (n3 ∩ n4) = {p1}. similarli, e−(3, 4) = n3 − cell 3 cell 4 e+(3, 4)={p1} e_(3, 4)={p2,r1} p2 p1 r2 r1 figur 4: exampl of edg index of two point entiti {p1, p2} and two polygon entiti {r1, r2} between two row-wise adjac cell. (n3 ∩ n4) = {p2, r1}. if we know n3, e+(3, 4), and e−(3, 4), we can comput n4 accord to lemma 1, n4 = n3+e+(3, 4)− e−(3, 4) = {p1, r2}. the abov calcul also correspond to our intuit. p2, r1, r2 overlap with cell 3 while p1, r2 overlap with cell 4. when transit from cell 3 to 4, the algorithm will recogn that p2, r1 disappear and p1 is newli appear while the spatial condit of r2 is unchang. thu, we can insert p2, r1 in the disappear edg set and insert p1 in the appear edg set. obvious, edg index is ineffici for index a point  geometri. node index ha on it per point entiti and requir on token remov and on insert upon ani locat movement. edg index, howev, requir on at and on dt per point  entiti and two token remov and two insert dure the updat, in the worst case. in such a situat, we take advantag of us both accord to the spatial properti of entiti extens. in  summari, as shown in figur 3(c), our edg index method us edg structur for the aoi enabl entiti (a, e1, e2) while it us node structur for the point entiti (s). 4.5 optim issu in thi section, we describ sever optim techniqu for edg index, which reduc the algorithm complex  significantli. 4.5.1 singl-tabl approach: updat typic, there exist two practic polici for a region updat: full updat simpli remov everi token of the previou entiti  region and re-insert newli updat token into newli  posit area. increment updat onli remov the token whose spatial  relationship with the cell chang upon an updat and insert them into new edg structur that satisfi the new spatial condit. 4.5.2 two-tabl approach: separ move  entiti from stationari entiti so far, we have not address ani side-effect of token remov dure the updat oper. let us assum that an edg index is realiz with a hash tabl. insert a token is implement by  insert it at the head of the correspond hash bucket, henc the process time becom constant. howev, the token remov time depend on the expect number of token per hash bucket. therefor, the hash implement mai suffer from a signific system penalti when us with a huge number of popul  entiti. two-tabl edg index is design to make the token remov overhead constant. first, we split a singl edg structur that  index both stationari and move entiti into two separ edg 406 tabl 1: summari of notat for virtual entiti and their properti. symbol mean u set of popul object entiti o set of move object entiti, o ⊆ u uq set of popul user entiti q set of move user entiti, q ⊆ uq a set of avatar, a = {a|a ∈ u ∩ uq} i.p locat of entiti i where i ∈ (u ∪ uq) i.r aoi of entiti i where i ∈ (u ∪ uq) mi side length of entiti i where i ∈ (u ∪ uq). it is repres by the number of cell unit. m averag side length of the aoi of entiti v ar(mi) varianc of random variabl mi v maximum reachabl distanc. it is repres by the number of cell unit. structur. if an entiti is not move, it token will be place in a stationari edg structur. otherwis, it will be place with a  move edg. second, all move edg structur ar period reconstruct. after the reconstruct, all grid cell ar evalu to comput their visibl set. onc all the cell ar evalu, the move edg ar destroi and the reconstruct step follow. as a result, search oper on the move edg structur ar no longer  necessari and the system becom insensit to ani underli  distribut pattern and move speed of the entiti. a singli link list implement is us for the move edg structur. 5. analysi we analyz three index scheme quantit (node index, edg index, and two-tabl edg index) in term of memori util and process time. in thi analysi, we assum that node and edg structur ar implement with hash tabl. for hash tabl manipul we assum three memori-access function: token insert, token remov, and token scan. their process cost ar denot by ta, td, and ts, respect. a  token scan oper read the token in a hash bucket sequenti. it is extens us dure cell evalu. ts and td ar a function of the number of token in the bucket while ta is constant. for the purpos of analysi, we defin two random variabl. on variabl, denot by mo, repres the side length of the aoi of an entiti o. the side length ar uniformli distribut in the rang of [mmin, mmax]. the averag valu of mo is denot by m. the second random variabl v denot the x-direct or  ydirect maximum distanc of a move entiti dure a time  interv. the simul movement of an entiti dure the given time is also uniformli distribut in the rang of [0, v]. for a simpl calcul, both random variabl ar express as the number of cell unit. tabl 1 summar the symbol notat and their mean. 5.1 memori requir let the token size be denot by s. node index us s · |uq| memori unit for user entiti and s · Èo∈u (mo + 1)2 ≈ s(m2 + 2m + 1 + v ar(mo))|u| unit for object entiti. singl-tabl edg index consum s · |uq| storag unit for the user entiti and s · Èo∈u 2(mo + 1) ≈ 2s(m + 1)|u| for the object entiti. two-tabl edg index occupi s · |uq| unit for the user and s{ Èi∈o 2(mi+1)+ Èj∈(u−o) 2(mj +1)} ≈ 2s(m+1)|u| unit for the object. tabl 2 summar these result. in our target  aptabl 2: memori requir of differ index method. index method user entiti object entiti node index s · |uq| s((m + 1)2 + v ar(mo))|u| singl-tabl edg s · |uq| 2s(m + 1)|u| two-tabl edg s · |uq| 2s(m + 1)|u| plicat, our edg index method consum approxim m+1 2 time less memori space than node index. differ grid cell partit with edg method will lead to differ memori requir. for exampl, here ar two grid: a m × m grid and a 2m × 2m grid. the memori requir for the user entiti is unchang becaus it depend onli on the total number of user entiti. the memori requir for the object entiti ar approxim 2s(m + 1)|u| in the m × m grid case and 2s(2m + 1)|u| for the (2m) × (2m) grid. thu, a four time larger cell size will lead to an approxim two time smaller number of token. 5.2 process cost in thi section, we focu on the cost analysi of updat oper and cell evalu. for a fair comparison of the differ method, we onli analyz the run-time complex of move object and move user. 5.2.1 updat cost we assum that a set of move object o and a set of move user q ar known in advanc. similar to edg index, node index ha two updat  polici: full updat and increment updat. full updat, implement in q-index [13] and sina [10], remov all the old token from the old cell node structur and insert all the new token into the new cell node. the increment updat polici, implement by no exist work, remov and insert all the token whose spatial  condit chang dure a period. in thi analysi, we onli consid increment node index. to analyz the updat cost of node index, we introduc the maximum reachabl distanc (v), where the next locat of a  move entiti, whose previou locat wa at cell(0,0), is uniformli distribut over the (±v, ±v) grid cell space as illustr in  figur 5. we also assum that the given maximum reachabl distanc is less than ani side length of the aoi of the object in the  system; that is, v < mo where o ∈ o. as seen in figur 5, the next locat mai fall into three categori: area a, b, and the center cell area (0,0). if an object resid in the same cell, there will be no updat. if the object move into the area a, there will be (i + j)(mo + 1) − ij token insert and remov, where 1 ≤ i, j ≤ v. otherwis, there will be k(mo + 1) token insert and remov, where 1 ≤ k ≤ v. thu, the expect  process time of an object updat for node index is the summat of three differ movement type t node per updat(o) = 4 · (a) + 4 · (b) (2v + 1)2 · (ta + td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (ta + td) (3) and the expect process time of ani object for node index is obtain by t node per updat = Èo∈o,v<mo t node per updat(o) |o| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (ta + td) (4) . 407 tabl 3: updat time cost for ani singl updat event where v < mq, mo and q ∈ q. index method queri ×(ta + td) (second) object ×(ta + td) (second) node index with increment updat |q| |o| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 singl-tabl edg index with full updat |q| |o| · 2(m + 1) singl-tabl edg index with increment updat |q| |o| · v(4m(1+2v)+9v+5) (2v+1)2 two-tabl edg index |q| · ta ta+td |o| · 2(m + 1) ta ta+td maximum reachabl distanc (v) (0,0) i j (i,j) a a aa b b b b figur 5: illustr of next cell locat, cell(i, j), of a move entiti whose initi locat wa at cell (0, 0). the expect time of ani singl entiti updat for edg index with full updat is: t edgeful per updat = Èo∈o t edgeful per updat (o) |o| = 2(m + 1)(ta + td) (5) the analysi of the expect time of ani singl entiti updat for edg index with increment updat becom complic  becaus the time cost depend both on the side length of the entiti aoi and on the move speed. roughli speak, it worst-case process cost is the same as tedgeful per updat . due to space  limit we onli show the analysi result of the expect process time when v of ani object o ∈ o is smaller than mo: tedgeincrement per updat = Èo∈o,v<mo tedgeincrement per updat (o) |o| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (ta + td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · tedgeful per updat (6) all updat complex ar summar in tabl 3. in thi  tabl, it is evid that while the updat cost of the worst-case edg index (singl-tabl edg index with full updat polici)  depend onli on m, that of the best-case node index (node  index with increment updat polici) is still proport to two  variabl, v and m. for a smaller valu of v (v = 1), the updat cost of node index slightli outperform that of edg index (i.e., 12m+8 9 vs. 2(m + 1)). howev, as v increas, the perform gain is then immedi revers (i.e., 60m+24 25 versu 2(m + 1), where v = 2). anoth interest result is that two-tabl edg index  depend onli on the token insert cost, ta. typic, td is slightli 1 2 3 4 5 0 5 10 15 20 25 30 35 40 maximum reachabl distanc (v) (%) #ofaffectedtoken two−tabl edg index increment edg index full edg index increment node index figur 6: simul result of updat complex of  differ index method. the updat complex, the expect number of token remov and insert per object updat, is drawn as a function of maximum reachabl distanc (v). the averag side length of object aoi is 10% of the side length of a given 2-d map. greater than ta becaus td requir at least on token lookup  oper. after the lookup, td execut the revers oper of ta. thu, td mai well be express as (ta + tlookup) and can be  simplifi as (ta + |e| 2·b ·ts) where |e| is the size of the edg structur and b is the number of it hash bucket. from thi observ, we can infer that full updat of singl-tabl edg index take at least twice as long as the updat for two-tabl edg index. figur 6 show that full updat of edg index when the  maximum reachabl distanc is less than the side length of ani move entiti take constant time to updat the correspond edg  structur, which mainli depend on the side length of the given aoi. in thi figur we assum that the averag side length of the aoi is 0.1 (or 10 %). the node index method, howev, depend not onli on the side length but also on the reachabl distanc. thu the entiti updat in node index is much heavier than the full updat for edg index. as expect, these simul result valid a common belief that in less dynam environ, increment updat reduc the amount of token insert and remov notic while in  extrem dynam environ the reduct ratio becom  neglig. 5.2.2 cell evalu cost node index scan all entiti and then collect the user  entiti index on everi cell node. therefor, it would take |q|×ts to scan all user entiti. if everi node store (m2 +2m+1+v ar(mo))|o| m2 object entiti on averag, the expect complet time of on cell evalu will then be Èo∈o (m2 +2m+1+v ar(mo))|o| m2 · ts. if  everi cell ha at most on user entiti, the expect complet time of all cell evalu will be |q| · (m2 +2m+1+v ar(mo))|o| m2 · ts. the runtim complex of the singl-tabl cell evalu can 408 tabl 4: summari of cell evalu cost. index method expect elaps time node index ts · |q| · (m2 +2m+1+v ar(mo))|o| m2 singl-tabl edg ts · (|q| + |o| · 2(m + 1)) two-tabl edg (ts + td) · (|q| + |o| · 2(m + 1)) be simplifi as ts ·|o|·2(m +1). in thi analysi, we do not  consid ani data deliveri overhead after a cell evalu. note that in singl-tabl edg index we need to scan all the token for cell evalu. two-tabl edg index execut in td to remov the evalu token after a cell evalu. unlik the td oper, the td oper is much lighter becaus it doe not requir ani lookup oper. tabl 4 show the expect complex of differ cell  evalu scenario. if previous comput result set ar re-us  dure the next evalu round, the expect elaps time of node index will be bound by the total number of cell evalu (i.e., ts(m2 + 2m + 1 + v ar(mo))|o|). howev, in the worst case, the cell evalu of node index is still m+1 2 time longer than that of ani edg index method. 5.2.3 put it togeth: period monitor cost as we saw in section 5.2.1, edg index method outperform node index in term of updat and cell evalu. in thi  section we focu on evalu the perform differ between singl-tabl edg index and two-tabl edg index. the total elaps time of full updat base singl-tabl edg  index for a given set of move entiti is the summat of the elaps time of updat and cell evalu: (ta + td + ts) · {|q| + |o|2(m + 1)} (7) similarli, the total elaps time of two-tabl edg index is as follow: (ta + td + ts) · {|q| + |o|2(m + 1)} (8) from equat 7 and 8 we conclud that two-tabl edg  index, even though it repres a minor optim of singl-tabl edg index by replac unpredict td with predict td, achiev a signific perform improv. first of all, td is veri predict and a more lightweight procedur than td. all the data structur manipul overhead, such as ta, ts, and td can be easili profil and all becom constant. in addit,  twotabl index is guarante to outperform singl-tabl full updat edg index. anoth novelti of the two-tabl approach is that it is highli resili to the underli data distribut, regardless of whether it is highli skew or uniform. equat 8 also reveal the minimum time interv that satisfi the given input paramet, ta, ts, td, |q|, |o|, and m. while ta, ts and td ar system-specif paramet, |o|, |q|, and m ar all applic-specif. the latter can be configur by the former and ani given real-time constraint t. thu, the system throughput - how mani move object and user ar support by the given system - is obtain from equat 9. maximum system throughput = |q| + |o|2(m + 1) = t ts + ta + td (9) for exampl, if a given sub-world is onli fill with move avatar, a = q = o, whose averag side length is 10% of the map side length, then ts + td take 0.42 microsecond per token evalu, and ta take 0.78 microsecond, and the system will handl about 36,231 avatar per second. everi avatar can navig in the sub-world freeli and the same number of remot connect client receiv the latest updat event continu. 6. evalu thi section present two simul setup and their perform result. section 6.1 examin whether our new view approach is superior to exist view model, in spite of it higher index complex. section 6.2 discuss the degre of practic and scalabl of our index method that is design for our new view model. 6.1 justificationofobject-initiatedview model 6.1.1 evalu metric to quantifi the qualiti of the retriev result of queri  process, we us two wide known evalu metric, precis (p) and recal (r), that estim the degre of accuraci and  comprehens of a given result set [15]. p is the ratio of relev,  retriev item to all retriev item. a lower valu of p impli that the queri result set contain a larg number of unnecessari object that do not have to be deliv to a client. a higher p valu mean a higher network traffic load than requir. r is the ratio of  relev, retriev item to all relev item. a lower r valu mean that more object that should be recogn ar ignor. from the r measur, we can quantit estim the occurr of object pop. in addit to the p and r metric, we us a standard  singlevalu queri evalu metric that combin p and r, call  emeasur [15]. the e-measur is defin as: e = 1 − (β2 + 1)pr β2p + r where β is the rel import of p or r. if β is equal to 1, p and r ar equal import. if β is less than 1, p becom more import. otherwis, r will affect the e-measur significantli. a lower e-measur valu impli that the test view model ha a higher qualiti. the best e-measur valu is zero, where the best valu for p and r ar both on. 6.1.2 simul setup we test four queri process scheme, which us either a user-initi or an object-initi view model: • user-initi visibl comput - rq-op: region queri - object point • object-orient visibl comput - pq-or: point queri - object region - rq-or: region queri - object region - acq-or: approxim cell queri - object region rq-op is the typic comput scheme that collect all  object whose locat is insid a user defin aoi. pq-or  collect a set of object whose aoi intersect with a given user point, formal {o|q.p ∈ o.r}. rq-or, an imaginari comput scheme, is the combin of rq-op and pq-or where the aoi of an object intersect with that of a user, {o|o.r ∩ q.r = ∅}. lastli, acq-or, an approxim visibl comput model, is a special scheme design for grid-base space partit, which is our choic of cell evalu methodolog for edg index. if a virtual space is partit into tile cell and a user point belong to on of the cell, the acq-or search the object whose aoi 409 tabl 5: p and r comput of differ visibl  determin scheme. scheme p r rq-op |{o|o.p ∈q.r∧q.p ∈o.r)}| |{o|o.p ∈q.r}| |{o|o.p ∈q.r∧q.p ∈o.r)}| |{o|q.p ∈o.r}| pq-or |{o|q.p ∈o.r}| |{o|q.p ∈o.r}| = 1 |{o|q.p ∈o.r}| |{o|q.p ∈o.r}| = 1 rq-or |{o|q.p ∈o.r}| |{o|q.r∩o.r=∅}| |{o|q.p ∈o.r}| |{o|q.p ∈o.r}| = 1 acq-or |{o|q.p ∈o.r}| |{o|c.r∩o.r=∅,q.p ∈c.r}| |{o|q.p ∈o.r}| |{o|q.p ∈o.r}| = 1 would intersect with the region of the correspond grid cell. of cours, it exhibit similar properti as rq-or while the result set of it queri is not a subset of the rq-or queri result. it identifi ani object o satisfi the condit c.r ∩ o.r = ∅ where the cell c satisfi q.p ∈ c.r as well. our simul program popul 100k object entiti and 10k user entiti in a 2d unit space, [0, 1) × [0, 1). the popul  entiti ar uniformli locat in the unit space. the side length of their aoi is also uniformli assign in the rang of [0.05, 0.14],  mean 5% to 14% of the side length of the unit space. the program perform intersect test between all user and all object entiti exhaust and comput the p, r, and e-measur valu (shown in tabl 5). 6.1.3 experiment result distribut of p and r measur: figur 7 show the  distribut of p and r for rq-op. we can observ that p and r ar roughli invers proport to each other when vari a user aoi rang. a smaller side length lead to higher accuraci but lower comprehens. for exampl, 5% of the side length of a user aoi detect all object whose side length of the aoi is at least 5%. thu, everi object retriev by rq-op is guarante to be all render at the client. but rq-op cannot detect the object outsid the aoi of the user, thu suffer from too mani miss object that should be render. similarli, the user whose aoi is wider than ani other aoi cannot miss ani object that should be render, but detect too mani unnecessari object. to remov ani object pop problem, the side length of ani aoi should be greater than or equal to the maximum visibl distanc of ani object in the system, which mai incur signific system degrad. e-measur distribut: figur 8 reveal two trend. first, the precis valu of rq-op lie in between those of acq-or (100 × 100 grid) and rq-or. second, the tendenc curv of the precis-to-e-measur plot of rq-or show resembl to that of acq-or. it look as if the two curv lie on the same  imaginari curv, which convei that acq-or inherit the properti of rq-or. effect of differ grid size: figur 9 show the statist differ of e-measur valu of seven differ grid partit scheme (us acq-or) and on rq-op model. we us a  boxand-whisker plot to show both median valu and the varianc of e-measur distribut and the outlier of each scheme. we also draw the median valu of the rq-op e-measur (green line) for comparison purpos. while the acq-or scheme have some outlier, their e-measur valu ar heavili concentr around the median valu, thu, thei ar less sensit to object aoi. as  expect, fine-grain grid partit show a smaller e-measur valu. the rq-op scheme show a wider varianc of it qualiti than other scheme, which is larg attribut to differ user side length. as the r measur becom more import, the queri qualiti of acq-or is improv more evid than that of  rqop. from figur 9, the 20×20 grid scheme had a better e-measur tabl 6: measur elaps time (second) of 100k move  object and 10k move user in a slowli move environ (v = 1). index updat time evalu time total singl-tablef ull 3.48 0.82 4.30 singl-tableincr 2.08 0.80 2.88 two-tabl 1.74 0.93 2.67 tabl 7: measur elaps time (second) of 100k move  object and 10k move user in a highli dynam environ (v = 15). index updat time evalu time total singl-tablef ull 3.65 0.77 4.42 singl-tableincr 3.49 0.74 4.23 two-tabl 1.75 0.93 2.68 valu in a priorit environ than in an equal-priorit  environ. as a result, we can roughli anticip that at least the 20×20 grid cell partit retriev a higher qualiti of visibl set than the rq-op. 6.2 evalu of edg index in thi section, we present the preliminari result of the  simul that examin the applic of our edg index  implement. to estim the degre of real-time support of our  index method, we us the total elaps time of updat all move entiti and comput visibl set for everi cell. we also  experi with differ grid partit polici and compar them with exhaust search solut. 6.2.1 simul setup we implement edg index algorithm in c and ran the  experi on a 64-bit 900mhz itanium processor with 8 gb of memori. we implement a gener hash tabl mechan to store node and edg structur. 6.2.2 experiment result period monitor cost: tabl 6 and 7 show the  perform number of differ edg index method by vari v. the move speed of entiti wa also uniformli assign between 0 and v. in a slowli move environ (tabl 6), the increment edg index method outperform full updat edg index, due to reduc index updat; the two-tabl approach surpass the  perform of singl-tabl scheme, mainli due to the lack of token lookup dure an updat. howev, the two-tabl method show a slightli higher evalu time than the two singl-tabl method becaus of it sequenti token remov. tabl 7 exemplifi the elaps time of index updat and cell evalu in a highli dynam environ where slowli  move and dynam move object co-exist. compar with the result shown in tabl 6, the two-tabl approach produc similar perform number regardless of the underli move  environ. howev, the perform gain obtain by the increment polici of the singl-tabl is decreas compar with that in the slowli move environ. effect of differ grid size: how mani object updat and cell evalu can be support in a given time period is an  import perform metric to quantifi system throughput. in thi section, we evalu the perform result of three differ  visibl comput model: two comput-driven exhaust search method; and on two-tabl edg index method with  differ grid size. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 recal (r) precis(p) 5% rang queri 6% rang queri 7% rang queri 8% rang queri 9% rang queri 10% rang queri 11% rang queri 12% rang queri 13% rang queri 14% rang queri optim 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 precis (p) e−measur optim rq−op rq−or acq−or (100x100 grid cell) 10x10 20x20 50x50 100x100 200x200 500x500 1kx1k rq−op 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 e−measur visibl test scheme median of rq−op figur 7: distribut of p and r  measur by rq-op. figur 8: e-measur valu as a function of precis valu p when β = 1. figur 9: e-measur valu as a function of acq-qr grid partit scheme when β = 2. 10k 50k 100k 10 −1 10 0 10 1 10 2 # of object updat (10k queri) totalelapsedtim(second) popul size = 100k, visibl rang = 5−15%, mobil = 1% exhaust search (intersect test) exhaust search (euclidean distanc measur) 200x200 two−tabl edg index 100x100 two−tabl edg index 50x50 two−tabl edg index figur 10: total elaps time of differ index scheme. exhaust search method do not maintain ani intermedi  result. thei simpli comput whether a given user point is insid a given object aoi. thei can toler unpredict behavior of object movement. in spite of their simpl design and  extens, thei suffer from lengthi comput delai to complet the visibl determin. figur 10 reveal the perform  differ between the exhaust solut and the two-tabl method, a differ of up to two order of magnitud. as shown in section 5, the total elaps time of object updat and cell evalu is linear with respect to the averag side length of object aoi. becaus the side length is repres by cell unit, an increas in the number of cell increas the side length  proportion. figur 10 illustr that the measur simul result roughli match the expect perform gain comput from the analysi. 7. conclus and futur work to support dynam extens and scalabl in highli dynam environ, we propos a new view paradigm, the object-initi view model, and it effici index method, edg index.  compar with the tradit view model, our new view model promis to elimin ani object pop problem that can easili be observ in exist virtual environ at the expens of increas  index complex. our edg index model, howev, can overcom such higher index complex by index spatial extens at edg-level not at node-level in a grid partit sub-world and wa valid through quantit analys and simul. howev, for now our edg index still retain a higher  complex, even in a two-dimension domain. current, we ar  develop anoth edg index method to make the index  complex constant. onc index complex becom constant, we plan to index 3d spatial extens and multi-resolut  geometri data. we expect that our edg index can contribut to  success deploy of next-gener game environ. 8. refer [1] d. marshal, d. delanei, s. mcloon, and t. ward, challeg in modern distribut interact applic design, tech. rep., depart of comput scienc, nation univers of ireland, maynooth, maynooth, col. kildar, ireland, 2004. [2] kuan-ta chen, polli huang, chun-ying huang, and chin-laung lei, game traffic analysi: an mmorpg perspect, in nossdav"05. 2005, pp. 19-24, acm press. [3] jaecheol kim, jaeyoung choi, dukhyun chang, taekyoung kwon, and yanghe choi, traffic charaterist of a massiv multiplay onlin role plai game and it implic, in netgam "05, oct 2005. [4] philip rosedal and cori ondrejka, enabl player-creat onlin world with grid comput and stream, gamastutra magazin, http://www.gamasutra.com/resourc guid/20030916/rosedal 01.shtml, septemb 2003. [5] eyal teler and dani lischinski, stream of complex 3d scene for remot walkthrough., comput. graph. forum, vol. 20, no. 3, 2001. [6] gerd hesina and dieter schmalstieg, a network architectur for remot render, in second intern workshop on distribut interact simul and real-time applic, 1998. [7] thoma a. funkhous and carlo h. sequin, adapt displai algorithm for interact frame rate dure visual of complex virtual environ, in siggraph "93, new york, ny, usa, 1993, pp. 247-254, acm press. [8] jussi myllymaki and jame kaufman, high-perform spatial index for locat-base servic, in www "03, new york, ny, usa, 2003, pp. 112-117, acm press. [9] m. lee, w. hsu, c. jensen, b. cui, and k. teo, support frequent updat in r-tree: a bottom-up approach, in vldb, page 608-619, 2003, 2003. [10] moham f. mokbel, xiaop xiong, and walid g. aref, sina: scalabl increment process of continu queri in spatio-tempor databas, in acm sigmod "04. 2004, pp. 623-634, acm press. [11] dmitri v. kalashnikov, sunil prabhakar, and susann e. hambrusch, main memori evalu of monitor queri over move object, distrib. parallel databas, vol. 15, no. 2, pp. 117-135, 2004. [12] haibo hu, jianliang xu, and dik lun lee, a gener framework for monitor continu spatial queri over move object., in sigmod confer, 2005. [13] s. prabhakar, y. xia, d. kalashnikov, w. aref, and s. hambrusch, queri index and veloc constrain index: scalabl techniqu for continu queri on move object, ieee transact on comput, vol. 51, no. 10, pp. 1124-1140, oct. 2002. [14] yuni xia and sunil prabhakar, q+rtree: effici index for move object databas, in dasfaa "03, washington, dc, usa, 2003, p. 175, ieee comput societi. [15] c. j. van rijsbergen, inform retriev, 2nd edit, dept. of comput scienc, univers of glasgow, 1979. 411 