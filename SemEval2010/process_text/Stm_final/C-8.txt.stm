oper context and context-base oper transform david sun comput scienc divis, eec univers of california berkelei, ca davidsun@cs.berkelei.edu chengzheng sun school of comput engin nanyang technolog univers singapor czsun@ntu.edu.sg abstract oper transform (ot) is a techniqu for  consist mainten and group undo, and is be appli to an increas number of collabor applic. the theoret foundat for ot is crucial in determin it capabl to solv exist and new problem, as well as the qualiti of those solut. the theori of causal ha been the foundat of all prior ot system, but it is  inadequ to captur essenti correct requir. past research had invent variou patch to work around thi problem, result in increasingli intric and complic ot algorithm. after have design, implement, and experi with a seri of ot algorithm, we reflect on what had been learn and set out to develop a new  theoret framework for better understand and resolv ot problem, reduc it complex, and support it continu evolut. in thi paper, we report the main  result of thi effort: the theori of oper context and the cot (context-base ot) algorithm. the cot algorithm is capabl of support both do and undo of ani  oper at anytim, without requir transform function to preserv revers properti, converg properti 2, invers properti 2 and 3. the cot algorithm is not onli simpler and more effici than prior ot control algorithm, but also simplifi the design of transform function. we have implement the cot algorithm in a gener  collabor engin and us it for support a rang of novel collabor applic. categori and subject descriptor c.2.4 [comput-commun network]:  distribut system-distribut applic; h.5.3 [inform interfac and present]: group and organ interfac-collabor comput; synchron  interact gener term algorithm, design, theori 1. introduct oper transform (ot) wa origin invent for consist mainten in plain-text group editor [4]. in over 15 year, ot ha evolv to support an increas number of applic, includ group undo [15, 19, 18, 21], group-awar [28], oper notif and  compress [20], spreadsheet and tabl-centric applic [14, 27], html/xml and tree-structur document edit [3, 7], word process and slide creation [29, 25, 24],  transpar and heterogen applic-share [1, 10, 24], and mobil replic comput and databas system [6, 16]. to effect and effici support exist and new  applic, we must continu to improv the capabl and qualiti of ot in solv both old and new problem. the sound of the theoret foundat for ot is crucial in thi process. on theoret underpin of all exist ot algorithm is causal/concurr [9, 17, 4, 22]: causal relat oper must be execut in their causal order; concurr oper must be transform befor their  execut. howev, the theori of causal is inadequ to captur essenti ot condit for correct transform. the limit of the causal theori had caus  correct problem from the veri begin of ot. the dopt algorithm wa the first ot algorithm and wa base sole on the concurr relationship among oper [4]: a pair of oper ar transform as long as thei ar  concurr. howev, later research discov that the  concurr condit alon is not suffici to ensur the  correct of transform. anoth condit is that the two concurr oper must be defin on the same  document state. in fact, the failur to meet the second  condit wa the root of the dopt-puzzl [22]. thi puzzl wa solv in variou wai, but the theori of causal as well as it limit were inherit by all follow-up ot algorithm. the causal theori limit becam even more  promin when ot wa appli to solv the undo problem in group editor. the concept of causal is unsuit to captur the relationship between an invers oper (as an interpret of a meta-level undo command) and other normal edit oper. in fact, the causal relat is not defin for invers oper (see section 2). variou patch were invent to work around thi problem,  result in more intric complic ot algorithm [18, 21]. after have design, implement, and experi with a seri of ot algorithm of increas complex, we reflect on what had been learn and set out to develop a uniform theoret framework for better understand and resolv ot problem, reduc it complex, and 279 support it continu evolut. in thi paper, we report the main result of thi effort: the theori of oper  context and the cot (context-base ot) algorithm. the rest of thi paper is organ as follow. first, we  defin causal-depend/-independ and briefli describ their limit in section 2. then, we present the kei  element of the oper context theori, includ the  definit of oper context, context-depend/-independ relat, context-base condit, and context vector in section 3. in section 4, we present the basic cot  algorithm for support consist mainten (do) and group undo under the assumpt that underli  transform function ar abl to preserv some import  transform properti. then, these transform properti and their pre-condit ar discuss in section 5. the cot solut to these transform properti ar  present in section 6. comparison of the cot work to prior ot work, ot correct issu, and futur work ar  discuss in section 7. final, major contribut of thi work ar summar in section 8. 2. limit of causal the theori of causal is central to distribut  comput and to the design of all exist ot algorithm.  follow lamport [9], causal-depend/-independ  relat among edit oper can be defin in term of their gener and execut sequenc [4, 23]. definit 1. causal-depend relat → given two oper oa and ob, gener at site i and j, ob is causal-depend on oa, denot by oa → ob, iff: (1) i = j and the gener of oa happen befor the  gener of ob; or (2) i = j and the execut of oa at site j happen befor the gener of ob; or (3) there exist an oper ox, such that oa → ox and ox → ob. 2 definit 2. causal-independ relat   given two oper oa and ob, oa and ob ar  causalindepend or concurr, denot by oa ob, iff neither oa → ob, nor ob → oa. 2 just as vector logic clock ar us for captur  casual in distribut system [17], state vector have been us for captur causal relationship among oper and for repres document state in ot system [4, 19, 23]. to illustr causal relat among oper, consid a real-time group edit session with two site in figur 1. there ar three edit oper in thi scenario (the undo command undo(o2) and it relat with other oper shall be explain later): o1 gener at site 0, and o2 and o3 gener at site 1. accord to definit 1 and 2, we have o2 → o3 becaus the gener of o2 happen befor the gener of o3; o1 o2 and o1 o3 becaus for each pair, neither oper"s execut happen befor the other oper"s gener. in the follow discuss, we shall us the term  ittransform to mean the us of the it (inclus  transform) function: it(oa, ob), which transform oper oa against oper ob in such a wai that the impact of ob is effect includ in oa [23]. thi term is introduc to differenti thi special transform function from other step involv in a transform process. figur 1: a real-time group edit scenario. the scenario in figur 1 (without the undo command) ha often been us to illustr the dopt-puzzl. under the dopt algorithm [4], when o2 arriv at site 0, it will be  ittransform against o1 sinc o2 o1; thi is correct becaus o2 and o1 ar defin on the same (initi) document state. when o3 arriv at site 0, it will also be it-transform against o1 sinc o3 o1; but thi is incorrect becaus o3 is defin on the document state that contain the effect of o2, wherea o1 is defin on the initi document state. in thi case, the paramet of o3 and o1 ar not compar and henc mai not be it-transform correctli. the solut to thi puzzl is first to it-transform o1 against o2 to produc o1, which is defin on the document state includ the effect of o2 (the same state on which o3 is defin), and then to it-transform o3 against o1 [22]. from definit 1 and 2, it is clear that the  causaldepend relat is onli defin for origin oper (e.g. o1, o2 and o3) directli gener by user, but not for transform oper (e.g. o1). furthermor, the  concurr relat doe not captur the essenti condit for correct it-transform: the two input oper must be defin on the same document state [23]. anoth major limit of causal is it unsuit for captur ot condit for invers oper. the undo(o2) command in figur 1 is interpret as an invers oper o2. the correct undo effect for o2 is to elimin the effect of o2 but retain the effect of other oper (i.e. o1 and o3) [21]. to achiev thi effect, o2 need to be treat as an oper defin on the document state includ the effect of o2 but not o1 and o3, so that o2 can be transform against o1 and o3 befor it execut. howev, accord to lamport"s happen-befor relat [9], undo(o2) is causal depend on o1, o2, and o3. if o2 wa to inherit the causal relat of undo(o2), then it would be effect treat as an oper defin on the  document state with the effect of all three oper o1, o2, and o3, which would prohibit o2 from be transform against ani oper, thu fail to achiev the correct undo effect. moreov, after execut an invers  oper like o2, the document state can no longer be properli repres by the state vector, which is onli capabl of repres origin normal edit oper. 3. oper context 3.1 basic concept conceptu, each oper o is associ with a  context, denot by c(o), which correspond to the document 280 state on which the oper is defin. the signific of oper context is twofold: (1) an oper can be  correctli execut onli if it context and the current document state ar the same; and (2) an oper can be correctli  ittransform against anoth oper onli if the context of these two oper ar the same. in figur 1, both o1 and o2 ar defin on the same  initi document so thei ar associ with the same context; o3 is defin on the document state which includ the effect of o2, so c(o3) is differ from c(o1) or c(o2). when o2 arriv at site 0, it cannot be execut as-is sinc c(o2) doe not match the current document state at site 0 which includ the effect of o1. o2 can be correctli it-transform against o1 sinc their context correspond to the same  initi document state. when o3 arriv at site 0, it cannot be execut as-is either sinc c(o3) doe not match the current document state at site 0 which includ the effect of both o1 and o2. o3 cannot be correctli it-transform against o1 sinc their context ar differ, which is the root of the dopt-puzzl. as discuss in section 2, undo(o2) should be interpret as an invers o2 defin on the document state with the effect of o2 onli. 3.2 set represent of oper context to facilit comparison and manipul of oper context for correct execut and transform, it is  necessari to explicitli repres oper context. in ot system, there ar two differ kind of oper: origin oper which ar gener by user, and  transform oper which ar the outcom of some  transform. origin oper can be further divid into two class: normal oper which ar gener to do someth, and invers oper which ar gener to undo some execut oper. for ani oper o, it invers is denot by o. sinc everi transform oper must come from an origin oper, we us the notat org(o) to denot the origin oper of o. if o is an origin oper, then org(o) = o. sinc the context of an oper correspond to the  document state on which the oper is defin, the problem of context represent can be reduc into the problem of document state represent. in an ot-base group editor, each document state can be uniqu repres by the set of origin oper execut so far on the  document. these origin oper mai be execut in differ order or in differ (origin or transform) form at  differ site, but the same document state must be achiev (accord to the converg requir [23]). we us origin (normal and invers) oper, rather than their transform version, to repres a document state. definit 3. document state represent a document state can be repres by ds as follow: 1. the initi document state is repres by ds = {}. 2. after execut an oper o of ani type on the document state repres by ds, the new document state is repres by ds = ds ∪ {org(o)}. 2 thi present doe not specifi what execut form the origin oper in ds should take to bring the  document to the current state, but it captur essenti and suffici inform for detect whether two document state ar the same and for deriv their differ in term of origin oper. base on the document state represent, the context of an origin normal oper should be the same as the represent of the document state from which thi  oper wa gener. to achiev the undo effect in [21], an origin invers oper o should be defin on the document state ds = c(o) ∪ {o}, which is the state  after execut the origin oper o on the state c(o). accord to the definit of the it function [23], a  transform oper o , where o = it(o, ox), should be  defin on the document state ds = c(o)∪{org(ox)}, which is the state achiev by execut ox on the state c(o). more precis, the context of an oper is defin blow. definit 4. the context of an oper 1. for an origin normal oper o, c(o) = ds, where ds is the represent of the document state from which o wa gener. 2. for an origin invers oper o, c(o) = c(o) ∪ {o}, where o is the oper to be undon. 3. for a transform oper o , c(o ) = c(o) ∪ {org(ox)}, where o = it(o, ox). 2 accord to the abov definit, the context of ani type of oper can be repres as a set of origin oper. for the scenario in figur 1, we have c(o1) = {}, c(o2) = {}, and c(o3) = {o2} accord to definit 4-item 1. accord to definit 4-item 2, we have c(o2) = {o2}. from o2 = it(o2, o1), we have c(o2) = {o1} accord to definit 4-item 3. 3.3 context-depend/-independ we defin the context-depend/-independ relat among oper in term of whether an origin oper is includ in the context of anoth oper of ani type. definit 5. context-depend relat  c → given an origin oper oa and an oper ob of ani type, ob is context-depend on oa, denot by oa c → ob, iff: (1) oa ∈ c(ob); or (2) there exist an origin oper ox, such that oa ∈ c(ox) and ox ∈ c(ob). 2 it should be note that the context-depend relat is defin onli between an origin (either normal or invers) oper and anoth oper of ani type (origin or transform). thi is becaus ani oper ha a context, but onli origin oper can be includ in a context. definit 6. context-independ relat  c  given two origin oper oa and ob, oa and ob ar context-independ, denot by oa c ob, iff neither oa c → ob, nor ob c → oa. 2 it can be shown that if both oa and ob ar origin normal oper, then oa c → ob is equival to oa → ob; and oa c ob is equival to oa ob. in other word, the causal-depend/-independ relat is a special case of the context-depend/-independ relat. 3.4 context-base condit the follow context-base condit (cc) captur  essenti requir for oper execut and  transform in ot system: 281 cc1: c(o) ⊆ ds is a necessari condit for an origin oper o to be transform to the document state ds for execut. cc1 ensur that o is alwai execut after the  contextdepend oper includ in c(o). in other word, for ani origin oper ox, if ox c → o, then ox must be execut befor o. when o is an origin  normal oper, all oper which ar causal befor o must be includ in c(o) (accord to definit 1 and definit 5), so cc1 preserv the causal  order among origin normal oper [4, 22]. when o is an origin invers oper, c(o) must includ the oper to be undon by o (see definit 4-item 2), so cc1 preserv the do-undo order among normal and invers oper [21]. cc2: ds − c(o)1 is the set of oper that o must be transform against befor o is execut on the  document state ds. cc2 ensur that o is transform against all  contextindepend oper in ds befor it execut. it can be shown that, for ani ox in ds − c(o), it must be that ox c o. when o is an origin normal  oper, ds − c(o) must includ all execut  oper which ar concurr with o, so cc2 cover the condit that o should be transform against concurr oper [4, 22]. when o is an invers oper, cc2 cover the condit that o should be transform against all oper which ar execut after the oper to be undon by o [21]. cc3: c(o) = ds is a necessari condit for o to be  execut on the document state ds. cc3 is requir for correctli execut oper. cc4: c(oa) ⊆ c(ob) is a necessari condit for oa to be it-transform to the new context given by c(ob). cc4 is requir becaus if c(oa) ⊆ c(ob), then there must be an oper ox ∈ c(oa) but ox ∈ c(ob), which mean oa cannot be it-transform to the new context c(ob) sinc it-transform cannot remov thi ox from c(oa) (see definit 4-item3). cc5: c(ob) − c(oa) is the set of oper that oa must be transform against befor it-transform against ob. cc5 ensur that oa is transform against  contextindepend oper in c(ob) befor it-transform against ob. it can be shown that, for ani ox in c(ob) − c(oa), it must be that ox c oa, cc6: c(oa) = c(ob) is a necessari condit for oa to be it-transform against ob. cc6 is requir for correctli appli it function. in summari, cc1 and cc4 ar requir for ensur  correct order of oper execut/transform; cc2 and cc5 ar requir for select correct transform target oper; and cc3 and cc6 ar requir for  ensur correct oper execut/transform. these context-base condit form the foundat for the cot algorithm to be present in section 4 and section 6. 1 ds − c(o) is the set differ between ds and c(o). 3.5 context vector an import element of the oper context theori is the context vector, which repres the set of oper of a context in an effici wai. for notat conveni, we assum that a collabor edit session consist of n collabor site, identifi by 0, 1, . . . , n − 1. 3.5.1 repres origin normal oper origin normal oper gener at each site ar strictli sequenti, so each of them can be uniqu identifi by a pair of integ (sid, ns), where sid is the site identifi and ns is the local sequenc number of thi oper. let oij be an origin normal oper gener at site i with a sequenc number j. if oij is includ in a  context c(o), then oi1, oi2, . . . , oij−1 must also be includ in c(o) accord to definit 3 and definit 4.  therefor, all normal oper gener at the same site can be suffici character by the largest sequenc  number of these oper. all origin normal oper in a context can be partit into n group accord to their gener site, so n integ ar need for repres origin normal oper in a context. 3.5.2 repres origin invers oper an origin invers oper can be gener to undo an origin normal oper, or to redo an undon  oper. each origin invers oper directli or indirectli correspond to exactli on origin normal oper. for exampl, invers oper o mai be gener to undo o, and o mai be gener to undo o. both o and o  correspond to the same normal oper o. base on thi observ, all origin invers oper in an oper context can be group by their correspond origin  normal oper: on invers group for each undon origin normal oper. invers oper in the same invers group can be  further differenti by a sequenc number base on their  execut order within thi group. for exampl, o and o ar in the same invers group correspond to o, so o ha the sequenc number 1, and o ha the sequenc number 2. in gener, an invers can be identifi by a tripl (sid, ns, is), where sid and ns ar the site identifi and sequenc  number of the correspond normal oper, and is is the invers sequenc number within the group. sinc invers ar sequenti execut, the largest sequenc number in the group can be us to repres all invers in the group. invers group can be further partit into n invers cluster accord to the site identifi of their  correspond normal oper. the invers cluster at site i -  icican be express as follow: ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)], where each pair (nsj, isj), 0 ≤ j < k, repres an invers group with isj invers oper correspond to the  origin normal oper with sequenc number nsj at site i. if no normal oper at site i ha been undon, ici is empti. 3.5.3 repres normal and invers oper to repres an oper context with both origin  normal and invers oper, an n-dimension context  vector is defin below. 282 definit 7. context vector given an oper o, it context c(o) can be repres by the follow context vector cv (o): cv (o) = [ (ns0, ic0), (ns1, ic1), . . . , (nsn−1, icn−1) ], where, for 0 ≤ i ≤ n − 1, 1. nsi repres all origin normal oper gener at site i, and 2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk−1, isk−1)]  repres all invers oper for undo normal  oper gener at site i, where (nsj, isj), 0 ≤ j < k, repres an invers group with isj invers relat to the normal oper with sequenc number nsj. 2 in the absenc of invers oper in the oper  context, all ici, 0 ≤ i ≤ n − 1, would be empti and a context vector would be reduc to a state vector [4]. the vector represent of oper context can also be us as the vector represent of the document state. as an exampl, consid the document state after interpret the undo command undo(o2) in figur 1. sinc undo(o2) is interpret as an invers o2 (see section 4.2), the  document state after execut (the transform) o2 shall be ds = {o1, o2, o3, o2}. thi document state cannot be repres by a state vector but can be repres as a context vector as follow: cv (ds) = [(1, [ ]), (2, [(1, 1)]]. base on definit 7, it is straightforward to deriv the scheme for maintain the vector represent for the document state after execut each oper (accord to definit 3). moreov, the vector represent of  oper context can also be us to effici detect  contextdepend/-independ relat. due to space  limit, these technic detail ar omit in thi paper. 4. the basic cot algorithm in the basic cot algorithm, we assum each site  maintain a document state ds, which contain the set of origin oper execut so-far. thi is differ from the log or the histori buffer (hb) scheme in prior ot algorithm [4, 22, 23], which record a list of transform oper. we deliber leav the intern data structur of ds  unspecifi to keep the cot algorithm independ of the oper buffer strategi. in algorithm descript, we shall us the context set  represent c(o), rather than the context vector  represent cv (o). when an oper o is propag from the local site to remot site, howev, it is the context vector, not the context set, that is actual piggi-back on o for propag. the set of oper in c(o) can be easili determin from ds base on the inform in cv (o). the cot algorithm ha two part: the cot-do part for support consist mainten (do), and the  cotundo part for support undo. both part share the same core context-base transform procedur.  oper context and context-base condit ar central to the whole cot algorithm. 4.1 cot-do cot-do take two paramet: o - an origin oper to be execut, and ds - the current document state  represent. cot-do is invok onli if c(o) ⊆ ds (cc1), which ensur that all oper includ in the context of o have alreadi been execut on ds. algorithm 1. cot-do(o, ds) 1. transform(o, ds − c(o)); 2. execut o; ds := ds ∪ {org(o)}. procedur 1. transform(o, cd) repeat until cd = { }: 1. remov ox from cd, where c(ox) ⊆ c(o); 2. transform(ox, c(o) − c(ox)); 3. o := it(o, ox); c(o) := c(o) ∪ {org(ox)}. cot-do first invok procedur transform() to transform o against oper in ds − c(o) (cc2). thi is to  upgrad the context of o to ds. in step 2, it must be that c(o) = ds (cc3), so o is execut as-is, and the origin of o is ad to ds (accord to definit 3-item 2). the heart of cot-do is transform(o, cd), whose task is to transform o against oper in cd, which repres the context differ between c(o) and a new context on which o is to be defin. thi procedur repeat the  follow three step until cd becom empti: 1. remov an oper ox from cd, where c(ox) ⊆ c(o) (cc4). an oper ox meet thi condit can be determin if all oper in cd ar sort in the order of their execut and sequenti retriev. 2. the procedur transform() is recurs invok to transform ox against oper in c(o)−c(ox) (cc5). thi is to upgrad ox to the context of o, so that thei can be us for it transform in the next step. 3. after the recurs call to transform(), it must be that c(o) = c(ox) (cc6), so o is it-transform against ox, and the context of o is updat by ad the origin of ox (accord to definit 4-item 3). to show how cot-do work, we examin how it resolv the dopt-puzzl in figur 1. consid the oper  execut at site 0, with the initi document state ds0 = { }. 1. after the gener of o1, sinc c(o1) = ds0, o1 is execut as-is and ds0 is updat to ds1 = {o1}. 2. when o2 arriv with c(o2) = {}, transform(o2, ds1− c(o2)) is call, where ds1 − c(o2) = {o1}. insid transform(o2, {o1}), sinc c(o1) = c(o2), we have o2 := it(o2, o1), and c(o2) = {o1}. return from transform(o2, {o1}), we have c(o2) = ds1, so o2 is execut, and ds1 is updat to ds2 = {o1, o2}, where o2 = org(o2). 3. when o3 arriv with c(o3) = {o2}, transform(o3, ds2− c(o3)) is call, where ds2 − c(o3) = {o1}. insid transform(o3, {o1}), transform(o1, c(o3)−c(o1)) is recurs call, with c(o3) − c(o1) = {o2}, which is the kei step in detect the dopt-puzzl. in the recurs transform(o1, {o2}), sinc c(o2) = c(o1), we have o1 := it(o1, o2), and c(o1) = {o2}. return from the recurs, we have c(o1) = c(o3), so c(o3) := it(o3, o1) (the dopt-puzzl resolv here), and c(o3) = {o1, o2}, where o1 = org(o1). after return from transform(o3, {o1}), c(o3) = ds2; so o3 is execut, and ds2 is updat to ds3 = {o1, o2, o3}, where o3 = org(o3). 283 4.2 cot-undo to undo an oper o, a meta-level undo command undo(o) must be issu by a user. how to gener the undo command for select ani oper to undo is part of the undo polici [21]. thi paper is confin to the  discuss of the undo mechan, which determin how to undo the select oper in a given context. in cot-undo, undo(o) is interpret as an invers o, that is context-depend on oper in c(o) and o itself. cot-undo take two input paramet: o is the oper select to be undon, which can be ani oper done  sofar, and ds is the current document state represent. algorithm 2. cot-undo(o, ds) 1. o := makeinvers(o); c(o) := c(o) ∪ {o}; 2. cot-do(o, ds). cot-undo work by first creat an invers o by  invok makeinvers(o)2 , with it context c(o) := c(o) ∪ {o} (accord to definit 4-item 2), and then invok  cotdo to handl o. for exampl, to interpret undo(o2) in figur 1,  cotundo is invok with paramet o2 and ds = {o1, o2, o3}. first, o2 and c(o2) = {o2} ar creat. then, cot-do is invok with paramet o2 and ds. insid cot-do, transform(o2, ds − c(o2)) shall be invok, and o2 shall be correctli transform against o1 and o3 sinc cd = ds − c(o2) = {o1, o3}. thi exampl show that an  invers oper can be handl by cot-do in the same wai as other normal oper. thi is becaus context-base condit cc1 - cc6 ar uniformli applic to both  normal and invers oper. the basic cot algorithm is simpl yet power -  capabl of do and undo ani oper at anytim. among all prior ot system, onli the combin of goto and anyundo (refer as goto-anyundo) ha similar capabl [22, 21]. 5. transform properti cot is a high-level control algorithm respons for  determin which oper should be transform against other oper and in which order accord to  contextbas condit. anoth import compon of an ot system is the low-level transform function  respons for transform oper accord to their type and paramet. past research ha identifi a rang of  transform properti/condit that must be maintain for ensur the correct of an ot system. differ ot  system mai have differ control algorithm, differ  transform function, and differ divis of  respons among these compon. unlik goto-anyundo, the basic cot algorithm doe not us et (exclus transform) function [21], thu avoid the requir of the revers properti (rp) between it and et function [21]. similar to goto-anyundo, the basic cot algorithm assum that underli transform function ar  capabl of preserv the follow properti [4, 15, 19, 23, 21]: 2 the reader is refer to [25] for precis definit of three primit oper insert, delet and updat and their  correspond invers. the makeinvers(o) procedur directli  follow these definit. 1. converg properti 1 (cp1)3 . given a  document state ds, and oper oa, ob, if oa = it(oa, ob), and ob = it(ob, oa), then it must be: ds ◦ [oa, ob] = ds ◦ [ob, oa], which mean that [oa, ob] and [ob, oa] ar equival with respect to the effect on the document state ds. 2. converg properti 2 (cp2). given three  oper o, oa and ob, if oa = it(oa, ob) and ob = it(ob, oa), then it must be: it(it(o, oa), ob) = it(it(o, ob), oa), which mean that [oa, ob] and [ob, oa] ar equival with respect to the effect in transform. 3. invers properti 2 (ip2)4 . given ani oper ox and a pair of oper [o, o], it must be: it(it(ox, o), o) = it(ox, i) = ox, which mean that [o, o] and i ar equival with  respect to the effect in transform. 4. invers properti 3 (ip3). given two oper oa and ob, if oa := it(oa, ob), ob := it(ob, oa), and oa := it(oa, ob), then it must be: oa = oa, which mean the transform invers oper oa is equal to the invers of the transform oper oa. the abov transform properti ar import  discoveri of past research, but thei ar not uncondition requir. the pre-condit for requir them, howev, were never explicitli state in their specif, which ha unfortun caus quit some misconcept in ot  literatur. to explor altern solut to these properti, we explicitli state the pre-condit (pc) for cp1, cp2, ip2, and ip3 as follow: 1. pc-cp1: cp1 is requir onli if the ot system  allow the same group of context-independ oper to be execut in differ order. 2. pc-cp2: cp2 is requir onli if the ot system  allow an oper to be transform against the same group of context-independ oper in differ order. 3. pc-ip2: ip2 is requir onli if the ot system allow an oper ox to be transform against a pair of do and undo oper (o and o) on-by-on. 4. pc-ip3: ip3 is requir onli if the ot system allow an invers oper oa to be transform against  anoth oper ob that is context-independ of oa. 3 converg properti 1 & 2 in thi paper (and in [21]) ar the same as transform properti 1 & 2 in [19]. 4 there is anoth invers properti 1 (ip1) that is requir in an ot system for achiev the correct undo effect [21], but ip1 is not relat to it function. 284 there ar gener two wai to achiev ot correct with respect to these transform properti: on is to design transform function capabl of preserv these properti; the other is to design control algorithm capabl of break the pre-condit for requir these properti. past research ha shown that it is rel easi to  design transform function capabl of preserv cp1, but non-trivial to design and formal prove transform function capabl of preserv cp2, ip2 and ip3.  counterexampl illustr the violat of these properti in some earli publish transform function can be found in [23, 21, 8, 11]. it function capabl of preserv ip2 and ip3 had been devis in the context of anyundo [21], but our experi in implement these function reveal that those solut ar quick intric and ineffici (more analysi can be found in section 7). clearli, solv cp2, ip2 and ip3 at the control algorithm level ha the benefit of simplifi the design of  transform function and the ot system as a whole. in the  follow section, we extend the basic cot algorithm to provid simpl and effici solut to cp2, ip2 and ip3 at the control algorithm level. 6. cot solut to cp2, ip2, and ip3 a distinct featur of cot is that in everi  transform process (i.e. an invoc of transform(o, cd)), the whole set of transform target oper ar  determin in advanc, and avail in the context-differ  paramet cd (calcul by us context-base condit cc2 and cc5). with the knowledg of all oper  involv in the transform process, we ar abl to  properli arrang these oper to break the pre-condit for cp2, ip2, and ip3. 6.1 extend transform() procedur we extend the core procedur transform(o, cd) to take advantag of the global knowledg of oper in the  contextdiffer paramet cd for break pc-cp2, pc-ip2 and pc-ip3. the extend transform(), as shown in  procedur 2, retain the structur and main element of  procedur 1, but add solut to cp2, ip2, and ip3 in step 1 (ensur tpsafeti()) and in step 2-(c) (the if-then part). procedur 2. transform(o, cd) 1. if cd = { }, ensur tpsafeti(o, cd); 2. repeat until cd = { }: (a) remov the first oper ox from cd; (b) transform(ox, c(o) − c(ox)); (c) if ox is a do-undo-pair, then c(o) := c(o) ∪ {org(ox), org(ox)}; els o := it(o, ox); c(o) := c(o) ∪ {org(ox)}. procedur 3. ensur tpsafeti(o, cd) 1. ensur cp2-safeti: sort oper in cd in a total order that respect their context-depend order. 2. ensur ip2-safeti: for ani ox ∈ cd, if ox ∈ cd, then mark ox as a do-undo-pair, remov ox from cd. 3. ensur ip3-safeti: if o is invers, the invok make ip3safe invers(o, cd). procedur 4. make ip3safe invers(o, cd) 1. o := makeinvers(o); c(o) := c(o) − {o}; 2. ncd := {ox | ox ∈ cd and ox c o}; 3. transform(o, ncd); 4. o := makeinvers(o); c(o) := c(o) ∪ {o}; 5. cd := cd − ncd. 6.2 break the pre-condit for cp2 the cot solut to cp2 is to sort all oper in cd in a total order which respect their context-depend  order (in step 1 of ensur tpsafeti()). if an oper o is transform against the same group of context-independ oper in multipl invoc to transform(o, cd), thi group of oper must be includ in cd and sort in the same total order. therefor, o can never be transform against the same group of oper in differ order, thu break pc-cp2. it should be note that cd becom an order set after the sort. the first ox in cd must meet the condit c(ox) ⊆ c(o) in step 2(a) of transform(o, cd)  (procedur 1), so thi condit is no longer explicitli specifi in procedur 2. a correct total order for break  pccp2 can be conveni determin by us the  contextdepend relat among all oper plu the site  identifi of context-independ oper. there have been sever prior ot system capabl of  break pc-cp2, includ the got system (by an undo/redo scheme base on total order) [23], the soct4 system (by a control strategi base on global sequenc) [26], the nice system (by a central transform-base notifi) [20], and the tibot system (by a distribut synchron protocol base on time-intern) [12]. the cot solut to cp2 is uniqu and avoid the us of ani undo/redo or global sequenc/synchron. 6.3 break the pre-condit for ip2 the basic idea of the cot solut to ip2 is to make sure that an oper is never transform against a pair of do and undo oper on by on, thu break  pcip2. thi solut consist of two part: (1) step 2 of ensur tpsafeti(cd) coupl oper with their  correspond invers if thei ar all includ in the context  differ cd, and remov these invers from cd; (2) in step 2-(c) of transform(), if ox is found to be a do-undo-pair, the it-transform of o against ox is skip (effect treat thi pair as an ident oper) and the context of o is updat by ad two oper: {org(ox), org(ox)}. 6.4 break the pre-condit for ip3 the cot solut to ip3 is encapsul in the procedur make ip3safe invers(o, cd), which make o an ip3-safe invers with respect to the context differ cd. an  invers o is ip3-safe with respect to cd if it is made from a transform version of o, which ha includ all oper in cd that ar context-independ of o. under the control of cot, the ip3-safe invers o shall never be transform against oper that ar context-independ of o, thu break pc-ip3. the make ip3safe invers procedur work as follow: (1) creat oper o (the invers of o) and c(o) = c(o) − 285 {o}; (2) select all oper from cd which ar  contextindepend of o and creat a new context differ ncd; (3) transform o against oper in ncd (by recurs invok transform()); (4) creat a new invers from the transform o; and (5) creat a new cd by subtract ncd from the old cd (the new cd must maintain the  total order as requir for solv cp2). thi new invers o must be ip3-safe becaus it is creat from a  transform oper whose context ha includ all oper in ncd. the ip3-safe invers o shall never be transform against the oper in ncd sinc these oper have been remov from the new cd in step (5). 7. discuss 7.1 the theori of oper context the notion of oper context wa first propos in the got algorithm [23] and us in conjunct with the  theori of causal in follow-up goto and anyundo  algorithm [22, 21]. in prior work, the context of an oper o wa defin as a sequenc of transform oper which can be execut to bring the document from it initi state to the state on which o is defin. thi definit is directli coupl to the sequenti histori buffer strategi, which save execut oper in their execut form and  order. there wa no explicit represent of an oper context. context relationship among oper ar  deriv from the causal relationship plu the histori buffer posit relationship among oper [23, 21]. in thi paper, the concept of oper context is defin as a set of origin oper correspond to the  document state on which thi oper is defin. thi new concept of oper context is independ of the  underli oper buffer strategi and is explicitli repres as an oper set. base on the set represent of  oper context, essenti ot condit (cc1 - cc6) have been precis and concis captur. moreov, the  context vector ha been devis to effici repres both normal and invers oper in a context. the context vector is more gener than the state vector and potenti applic to other distribut comput system as well. base on the theori of causal, prior ot algorithm have us state vector to captur causal-depend  relationship among origin normal oper and to  repres document state in term of origin normal  oper. howev, causal-depend relationship ar not defin for invers or transform oper, and state  vector cannot repres document state with origin invers oper. the theori of causal is unabl to captur  essenti ot condit (cc1 - cc6) for all type of oper - origin and transform, normal and invers oper. 7.2 cot versu goto-anyundo both cot and goto-anyundo ar capabl of do and undo ani oper at anytim. the main  differ is that cot achiev thi capabl without us et function (thu elimin the rp requir for it  function), and without requir it function to preserv cp2, ip2 and ip3. the avoid of rp, cp2, ip2, and ip3 ha significantli simplifi the design of transform  function and the ot system as a whole. cot is simpler than goto-anyundo (and prior ot algorithm base on the causal theori) becaus of the us of a singl theori of oper context for captur all  otrel condit (cc1-cc6), the uniform of  contextbas condit for treat all type of oper, and the concis of these context-base condit. the cot-base system is more effici than the  gotoanyundo-base system in solv ip2 and ip3. in  gotoanyundo, the do-part (a normal oper) and the  undopart (an invers oper) need to be coupl for the  purpos of preserv ip2 [21]. an eager coupl strategi wa adopt: an invers oper is coupl with it  correspond normal oper immedi after it execut. under thi scheme, invers oper ar not explicitli  repres in the histori buffer. when a normal oper is to be execut, howev, it mai need to be transform against onli the undo-part of a do-undo-pair. to cope with thi problem, an extra decoupl-goto-recoupl scheme ha to be us to decoupl a do-undo-pair befor  invok goto and then recoupl them afterward [21].  howev, the implement of thi decoupl-recoupl scheme reveal it wa rather intric and caus mani repeat transform. in the cot algorithm, cot-do and cot-undo ar seamlessli integr. invers oper ar explicitli  repres in the oper context, and a lazi coupl  strategi is adopt: the coupl of a do-undo-pair occur not  immedi after execut each invers, but onli when both the do-part and the undo-part appear in the same  transform process at some late stage. these strategi help to avoid overhead transform caus by the eager coupl scheme and the decoupl-recoupl scheme. in the goto-anyundo-base system, the solut to ip3 is encapsul in an ip3-preserv it function, call ip3p-it [21]. insid thi function, an extend et function ha to be us, which mai invok the expens goto  algorithm to ensur rp with the correspond it function. in contrast, the cot solut to ip3 is encapsul in the high-level procedur make ip3safe invers(o, cd), which is more effici sinc (1) it avoid convert o to o back and forth multipl time for each ox ∈ ncd (if ip3p-it(o, ox) were us instead); and (2) the transform() procedur is much cheaper than goto. 7.3 ot buffer strategi anoth distinct featur of the cot algorithm is the separ of the algorithm from the underli oper buffer strategi. thi ha not onli result in a cleaner and simpler logic structur to the algorithm itself, but also allow a rang of perform optim at the  oper buffer level. we have devis and implement a buffer structur in which not onli origin oper but also transform  version can be save; and all transform oper from the same origin oper ar organ in the same version group. when an origin oper is requir at the cot algorithm level, the correspond version group is search for a version that match the context requir. if such a version alreadi exist, it is us to repres the  origin oper in the transform process, thu save the overhead to transform the origin oper into thi  version. under thi buffer structur, variou heurist can be us to select save transform version to maxim their reus and minim their space usag. by  experiment, we have identifi some us heurist that ar 286 effect in save transform for a number of common pattern of oper sequenc. cot is not the first ot algorithm that buffer and us origin oper for transform. sever prior ot algorithm, includ ccu [2], adopt [19], and  gotoanyundo [21], have also buffer origin oper. cot is uniqu in it wai of buffer and us origin, as well as transform, oper. 7.4 ot correct ot correct is a central topic of discuss in ot  research. in thi section, we provid our observ and opinion on some import ot correct issu. ot is a complex system with multipl interrel  compon. a system-orient approach is need for address ot issu. an experiment method, call  puzzl-detectionresolut, ha commonli been us in explor and  refin ot solut. puzzl ar subtl but repres scenario in which certain ot properti/condit mai be violat and the system mai produc incorrect result. the abil to solv all known puzzl is a necessari condit and an import indic of the sound of an ot  system. in research literatur, simpl puzzl scenario ar  often us to illustr the kei reason why an ot system work or fail. in real ot system design, howev, a real implement and comprehens test case base on complex puzzl scenario ar crucial in valid a design. theoret method have also been us to formal  verifi ot correct with respect to some identifi  transform properti/condit. formal verif can be effect if the correct issu have been well-understood and the verif criteria and boundari condit have been well-defin. in thi regard, experiment method like puzzl-detect-resolut can plai an import role in gain the necessari insight into the real correct issu, and establish suitabl criteria and condit for formal verif. a systemat approach is need in conduct both  experiment and theoret ot research. mani ot  compon and issu ar intim relat, and a solut to on issu, if examin in isol, is unlik to be  correct or complet. for exampl, a solut that work well for consist mainten (do), mai fail when both do and undo problem ar consid; and an undo solut (e.g. preserv ip2) mai violat the solut to  consist mainten [21]. a complet ot solut to both do and undo problem is significantli more difficult to design than a partial solut to onli on of them. on the other hand, a difficult issu in on ot compon mai be resolv easili, or avoid altogeth, if thi issu is address from a differ ot compon. for exampl, it is known that devis and prove transform  function capabl of preserv properti cp2, ip2, and ip3 ar difficult. howev, these difficulti can be avoid by devis control algorithm (like cot) capabl of break the pre-condit for requir these properti; it is also easier to prove a control algorithm is capabl of break the pre-condit for these properti, than to prove  transform function ar capabl of preserv them. differ ot system mai have differ divis of  respons among their compon and henc differ correct requir for these compon. caution must be taken in interpret correct result. for  exampl, cp1 and cp2 were proven to be necessari and  suffici for adopt-base system to converg [19, 13], but thi result cannot be gener to all ot system. in fact, cp1 and cp2 ar neither suffici nor necessari for mani ot system. thei ar insuffici becaus an ot system mai need to preserv addit properti/condit, such as ip2, ip3, and those summar in [21]. thei ar  unnecessari if the pre-condit for requir them have been broken. for exampl, neither cp1 nor cp2 is requir in the reduc system base on the got algorithm for ensur converg [23]. cp2 is also not requir by ot system base on cot or some prior ot algorithm [26, 20, 12]. on ot correct issu, which is often discuss in  relat to the cp2-violat problem, is the fals-tie problem: when two (or more) insert oper with the same posit ar it-transform with each other, the posit tie mai be fals if it wa not origin but caus by previou  transform. an ot system mai fail to produc correct result if the normal tie-break rule (e.g. base on site  identifi) is us to break fals-ti. thi problem wa long discov in earli ot work and a concret scenario relat to thi problem wa illustr in fig. 6 of [23]. it is beyond the scope of thi paper to discuss solut to thi problem, but it is worth point out that the fals-tie problem is differ from the cp2-violat problem: a fals-tie mai occur without violat cp2. in our view, the fals-tie problem is an issu at the transform function level and it solut could and should be local at thi level as well. for altern view and approach to thi problem, the reader is refer to [8, 11, 5]. the cot algorithm ha been implement and valid by a comprehens test suit cover all known ot puzzl scenario. in thi paper, inform analysi and  simpl puzzl scenario have been us to show the  correct of cot with respect to variou transform  properti/condit. formal verif of cot correct with respect to these properti/condit, and  quantit analysi of the time and space complex of cot, shall be report in a journal version of thi paper. 8. conclus we have contribut the theori of oper context and the cot (context-base ot) algorithm. the theori of  oper context is capabl of captur essenti relationship and condit for all type of oper in an ot system; it provid a new foundat for better understand and resolv ot problem. the cot algorithm provid  uniform solut to both consist mainten and undo problem; it is simpler and more effici than prior ot  control algorithm with similar capabl; and it significantli simplifi the design of transform function. the cot algorithm ha been implement in a gener collabor engin and us for support a rang of novel collabor applic [24]. real-world applic provid excit opportun and challeng to futur ot research. the theori of oper context and the cot algorithm shall serv as new  foundat for address the technic challeng in exist and emerg ot applic. acknowledg the author ar grate to bo begol and anonym  review for their valuabl comment and suggest which have help improv the present of the paper. 287 9. refer [1] j. begol, m. rosson, and c. shaffer. flexibl collabor transpar: support worker independ in replic applic-share system. acm tran. on comput-human interact, 6(2):95-132, 1999. [2] g. cormack. a calculu for concurr updat. in research report cs-95-06, dept. of comput scienc, univers of waterloo, canada, 1995. [3] a. davi, c. sun, and j. lu. gener oper transform to the standard gener markup languag. in proc. of the acm conf. on comput-support cooper work, page 58 - 67, nov. 2002. [4] c. a. elli and s. j. gibb. concurr control in groupwar system. in proc. of the acm conf. on manag of data, page 399-407, mai 1989. [5] n. gu, j. yang, and q.zhang. consist mainten base on the mark & retrac techniqu in groupwar system. in proc. of acm conf. on support group work, page 264-273, nov. 2005. [6] r. guerraoui and corin hari. on the consist problem in mobil distribut comput. in proceed of the second acm intern workshop on principl of mobil comput, page 51-57, new york, octo 2002. acm. [7] c. ignat and m.c. norri. customiz collabor editor reli on treeopt algorithm. in proc. of the european conf. of comput-support cooper work, page 315-324, sept. 2003. [8] a. imin, p. molli, g. oster, and m. rusinowitch. prove correct of transform function in real-time groupwar. in proc. of the european conf. on comput-support cooper work, sept. 2003. [9] l. lamport. time, clock, and the order of event in a distribut system. commun of acm, 21(7):558-565, 1978. [10] d. li and r. li. transpar share and interoper of heterogen singl-user applic. in proc. of the acm conf. on comput-support cooper work, page 246-255, nov. 2002. [11] d. li and r. li. preserv oper effect relat in group editor. in proc. of the acm conf. on comput-support cooper work, page 457-466, nov. 2004. [12] r. li, d. li, and c. sun. a time interv base consist control algorithm for interact groupwar applic. in proc. of intern confer on parallel and distribut system, page 429-436, juli. 2004. [13] b. lushman and g. cormack. proof of correct of ressel adopt algorithm. inform process letter, (86):303-310, 2003. [14] c. palmer and g. cormack. oper transform for a distribut share spreadsheet. in proc. of the acm conf. on comput-support cooper work, page 69-78, nov. 1998. [15] a. prakash and m. knister. a framework for undo action in collabor system. acm tran. on comput-human interact, 4(1):295-330, dec. 1994. [16] n. preguica, m. shapiro, and j. legatheaux martin. autom semant-base reconcili for mobil databas. in proceed of the 3th confer francais sur le system d"exploit, octo 2003. [17] m. raynal and m. singhal. logic time: captur causal in distribut system. ieee comput magazin, 29(2):49-56, feb. 1996. [18] m. ressel and r. gunzenh¨auser. reduc the problem of group undo. in proc. of the acm conf. on support group work, page 131-139, nov. 1999. [19] m. ressel, d. nitsch-ruhland, and r. gunzenh¨auser. an integr, transform-orient approach to concurr control and undo in group editor. in proc. of the acm conf. on comput-support cooper work, page 288-297, nov. 1996. [20] h.f. shen and c. sun. a flexibl notif framework for collabor system. in proc. of the acm conf. on comput-support cooper work, page 77-86, nov. 2002. [21] c. sun. undo as concurr invers in group editor. acm tran. on comput-human interact, 9(4):309-361, decemb 2002. [22] c. sun and c. a. elli. oper transform in real-time group editor: issu, algorithm, and achiev. in proc. of the acm conf. on comput-support cooper work, page 59-68, nov. 1998. [23] c. sun, x. jia, y. zhang, y. yang, and d. chen. achiev converg, causal-preserv, and intent-preserv in real-time cooper edit system. acm tran. on comput-human interact, 5(1):63-108, march 1998. [24] c. sun, q. xia, d. sun, d. chen, h.f. shen, and w. cai. transpar adapt of singl-user applic for multi-user real-time collabor. acm tran. on comput-human interact, 2006. [25] d. sun, s. xia, c. sun, and d. chen. oper transform for collabor word process. in proc. of the acm conf. on comput-support cooper work, page 437-446, nov. 2004. [26] n. vidot, m. cart, j. ferri´e, and m. suleiman. copi converg in a distribut real-time collabor environ. in proc. of the acm conf. on comput-support cooper work, page 171-180, dec. 2000. [27] s. xia, d. sun, c. sun, and d. chen. a collabor tabl edit techniqu base on transpar adapt. in proc. of the intern conf. on cooper inform system, lnc vol. 3760, springer verlag, page 576-592, nov. 2005. [28] s. xia, d. sun, c. sun, and d. chen. object-associ telepoint for real-time collabor document edit system. in proc. of the ieee conf. on collabor comput: network, applic and workshar, dec. 2005. [29] s. xia, d. sun, c. sun, d. chen, and h.f. shen. leverag singl-user applic for multi-user collabor: the coword approach. in proc. of the acm conf. on comput-support cooper work, page 162-171, nov. 2004. 288 