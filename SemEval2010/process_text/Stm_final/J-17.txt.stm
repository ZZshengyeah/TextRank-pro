truth mechan design for multi-dimension schedul via cycl monoton ron lavi industri engin and manag the technion - israel institut of technolog ronlavi@ie.technion.ac.il chaitanya swami combinator and optim univers of waterloo cswami@math.uwaterloo.ca abstract we consid the problem of makespan minim on m unrel machin in the context of algorithm mechan design, where the machin ar the strateg player. thi is a multidimension schedul domain, and the onli known posit result for makespan minim in such a domain ar o(m)-approxim truth mechan [22, 20]. we studi a well-motiv special case of thi problem, where the process time of a job on each machin mai either be low or high, and the low and high valu ar public and job-depend. thi preserv the  multidimension of the domain, and gener the restrict-machin (i.e., {pj, ∞}) set in schedul. we give a gener  techniqu to convert ani c-approxim algorithm to a  3capproxim truth-in-expect mechan. thi is on of the few known result that show how to export  approxim algorithm for a multidimension problem into truth mechan in a black-box fashion. when the low and high valu ar the same for all job, we devis a  determinist 2-approxim truth mechan. these ar the first truth mechan with non-trivial perform guarante for a multidimension schedul domain. our construct ar novel in two respect. first, we do not util or reli on explicit price definit to prove truth; instead we design algorithm that satisfi  cycl monoton. cycl monoton [23] is a necessari and suffici condit for truth, is a gener of valu monoton for multidimension domain.  howev, wherea valu monoton ha been us extens and successfulli to design truth mechan in  singledimension domain, our is the first work that leverag cycl monoton in the multidimension set. second, our random mechan ar obtain by first  construct a fraction truth mechan for a fraction  relax of the problem, and then convert it into a  truthfulin-expect mechan. thi build upon a techniqu of [16], and show the us of fraction mechan in truth mechan design. categori and subject descriptor f.2 [analysi of algorithm and problem  complex]; j.4 [social and behavior scienc]: econom gener term algorithm, econom, theori 1. introduct mechan design studi algorithm construct  under the presenc of strateg player who hold the input to the algorithm. algorithm mechan design ha  focus mainli on set were the social planner or design wish to maxim the social welfar (or equival,  minim social cost), or on auction set where  revenuemaxim is the main goal. altern optim goal, such as those that incorpor fair criteria (which have been investig algorithm and in social choic theori), have receiv veri littl or no attent. in thi paper, we consid such an altern goal in the context of machin schedul, name, makespan  minim. there ar n job or task that need to be assign to m machin, where each job ha to be assign to exactli on machin. assign a job j to a machin i incur a load (cost) of pij ≥ 0 on machin i, and the load of a machin is the sum of the load incur due to the job assign to it; the goal is to schedul the job so as to minim the  maximum load of a machin, which is term the makespan of the schedul. makespan minim is a common object in schedul environ, and ha been well studi  algorithm in both the comput scienc and oper research commun (see, e.g., the survei [12]). follow the work of nisan and ronen [22], we consid each machin to be a strateg player or agent who privat know it own process time for each job, and mai misrepres these valu in order to decreas it load (which is it incur cost). henc, we approach the problem via mechan  design: the social design, who hold the set of job to be assign, need to specifi, in addit to a schedul, suitabl payment to the player in order to incentiv them to  reveal their true process time. such a mechan is call a truth mechan. the makespan-minim  object is quit differ from the classic goal of social-welfar maxim, where on want to maxim the total  welfar (or minim the total cost) of all player. instead, it 252 correspond to maxim the minimum welfar and the  notion of max-min fair, and appear to be a much harder problem from the viewpoint of mechan design. in  particular, the celebr vcg [26, 9, 10] famili of mechan doe not appli here, and we need to devis new techniqu. the possibl of construct a truth mechan for makespan minim is strongli relat to assumpt on the player" process time, in particular, the  dimension of the domain. nisan and ronen consid the set of unrel machin where the pij valu mai be  arbitrari. thi is a multidimension domain, sinc a player"s privat valu is it entir vector of process time (pij)j. veri few posit result ar known for multidimension domain in gener, and the onli posit result known for multidimension schedul ar o(m)-approxim  truth mechan [22, 20]. we emphas that regardless of comput consider, even the exist of a  truth mechan with a significantli better (than m)  approxim ratio is not known for ani such schedul domain. on the neg side, [22] show that no truth  determinist mechan can achiev approxim ratio better than 2, and strengthen thi lower bound to m for two  specif class of determinist mechan. recent, [20]  extend thi lower bound to random mechan, and [8] improv the determinist lower bound. in stark contrast with the abov state of affair, much stronger (and mani more) posit result ar known for a special case of the unrel machin problem, name, the set of relat machin. here, we have pij = pj/si for everi i, j, where pj is public knowledg, and the speed si is the onli privat paramet of machin i. thi  assumpt make the domain of player" type singl-dimension. truth in such domain is equival to a conveni valu-monoton condit [21, 3], which appear to make it significantli easier to design truth mechan in such domain. archer and tardo [3] first consid the relat machin set and gave a random 3-approxim truth-in-expect mechan. the gap between the singl-dimension and multidimension domain is perhap best exemplifi by the fact that [3] show that there  exist a truth mechan that alwai output an optim schedul. (recal that in the multidimension unrel machin set, it is imposs to obtain a truth  mechan with approxim ratio better than 2.) variou follow-up result [2, 4, 1, 13] have strengthen the notion of truth and/or improv the approxim ratio. such difficulti in move from the singl-dimension to the multidimension set also aris in other mechan design set (e.g., combinatori auction). thu, in  addit to the specif import of schedul in strateg environ, idea from multidimension schedul mai also have a bear in the more gener context of truth mechan design for multidimension domain. in thi paper, we consid the makespan-minim problem for a special case of unrel machin, where the process time of a job is either low or high on each machin. more precis, in our set, pij ∈ {lj, hj} for everi i, j, where the lj, hj valu ar publicli known (lj ≡low, hj ≡high). we call thi model the  jobdepend two-valu case. thi model gener the  classic restrict machin set, where pij ∈ {lj, ∞} which ha been well-studi algorithm. a special case of our model is when lj = l and hj = h for all job j, which we denot simpli as the two-valu schedul model. both of our domain ar multidimension, sinc the machin ar unrel: on job mai be low on on machin and high on the other, while anoth job mai follow the opposit  pattern. thu, the privat inform of each machin is a vector specifi which job ar low and high on it. thu, thei retain the core properti underli the hard of truth mechan design for unrel machin, and by studi these special set we hope to gain some insight that will be us for tackl the gener problem. our result and techniqu we present variou  posit result for our multidimension schedul domain. our first result is a gener method to convert ani  capproxim algorithm for the job-depend two valu set into a 3c-approxim truth-in-expect  mechan. thi is on of the veri few known result that us an approxim algorithm in a black-box fashion to obtain a truth mechan for a multidimension problem. our result impli that there exist a 3-approxim  truthfulin-expect mechan for the lj-hj set.  interestingli, the proof of truth is not base on suppli  explicit price, and our construct doe not necessarili yield effici-comput price (but the alloc rule is  effici comput). our second result appli to the  twovalu set (lj = l, hj = h), for which we improv both the approxim ratio and strengthen the notion of  truth. we obtain a determinist 2-approxim truth mechan (along with price) for thi problem. these ar the first truth mechan with non-trivial perform guarante for a multidimension schedul domain.  complement thi, we observ that even thi seemingli simpl set doe not admit truth mechan that return an optim schedul (unlik in the case of relat machin). by exploit the multidimension of the domain, we prove that no truth determinist mechan can obtain an approxim ratio better than 1.14 to the makespan (irrespect of comput consider). the main techniqu, and on of the novelti,  underli our construct and proof, is that we do not reli on explicit price specif in order to prove the  truth of our mechan. instead we exploit certain  algorithm monoton condit that character  truth to first design an implement algorithm, i.e., an  algorithm for which price ensur truth exist, and then find these price (by further delv into the proof of  implement). thi kind of analysi ha been the method of choic in the design of truth mechan for  singledimension domain, where valu-monoton yield a  conveni character enabl on to concentr on the algorithm side of the problem (see, e.g., [3, 7, 4, 1, 13]). but for multidimension domain, almost all posit  result have reli on explicit price specif in order to prove truth (an except is the work on unknown singl-mind player in combinatori auction [17, 7]), a fact that yet again show the gap in our understand of multidimension vs. singl-dimension domain. our work is the first to leverag monoton condit for truth mechan design in arbitrari domain. the monoton condit we us, which is sometim call cycl monoton, wa first propos by rochet [23] (see also [11]). it is a gener of valu-monoton and complet character truth in everi domain. our method and analys demonstr the potenti benefit 253 of thi character, and show that cycl monoton can be effect util to devis truth mechan for multidimension domain. consid, for exampl, our first result show that ani c-approxim algorithm can be export to a 3c-approxim truth-in-expect mechan. at the level of gener of an arbitrari  approxim algorithm, it seem unlik that on would be abl to come up with price to prove truth of the construct mechan. but, cycl monoton doe allow us to prove such a statement. in fact, some such condit base onli on the underli algorithm (and not on the price) seem necessari to prove such a gener statement. the method for convert approxim algorithm into truth mechan involv anoth novel idea. our  random mechan is obtain by first construct a  truth mechan that return a fraction schedul. move to a fraction domain allow us to plug-in truth into the approxim algorithm in a rather simpl  fashion, while lose a factor of 2 in the approxim ratio. we then us a suitabl random round procedur to convert the fraction assign into a random integr  assign. for thi, we us a recent round procedur of kumar et al. [14] that is tailor for unrel-machin schedul. thi preserv truth, but we lose anoth addit factor equal to the approxim ratio. our  construct us and extend some observ of lavi and swami [16], and further demonstr the benefit of  fraction mechan in truth mechan design. relat work nisan and ronen [22] first consid the makespan-minim problem for unrel machin. thei gave an m-approxim posit result and prove variou lower bound. recent, mu"alem and schapira [20] prove a lower bound of 2 on the approxim ratio achiev by truth-in-expect mechan, and christodoul, koutsoupia, and vidali [8] prove a (1 + √ 2)-lower bound for determinist truth mechan.archer and tardo [3] first consid the relat-machin problem and gave a 3-approxim truth-in-expect mechan. thi been improv in [2, 4, 1, 13] to: a 2-approxim  random mechan [2]; an fpta for ani fix number of machin given by andelman, azar and sorani [1], and a 3-approxim determinist mechan by kov´ac [13]. the algorithm problem (i.e., without requir  truth) of makespan-minim on unrel machin is well understood and variou 2-approxim algorithm ar known. lenstra, shmoi and tardo [18] gave the first such algorithm. shmoi and tardo [25] later gave a  2approxim algorithm for the gener assign  problem, a gener where there is a cost cij for assign a job j to a machin i, and the goal is to minim the cost subject to a bound on the makespan. recent, kumar, marath, parthasarathi, and srinivasan [14] gave a  random round algorithm that yield the same bound. we us their procedur in our random mechan. the character of truth for arbitrari domain in term of cycl monoton seem to have been first  observ by rochet [23] (see also gui et al. [11]). thi  gener the valu-monoton condit for singl-dimension domain which wa given by myerson [21] and rediscov by [3]. as mention earlier, thi condit ha been  exploit numer time to obtain truth mechan for singl-dimension domain [3, 7, 4, 1, 13]. for convex  domain (i.e., each player" set of privat valu is convex), it is known that cycl monoton is impli by a simpler condit, call weak monoton [15, 6, 24]. but even thi simpler condit ha not found much applic in truth mechan design for multidimension problem. object other than social-welfar maxim and  revenu maxim have receiv veri littl attent in  mechan design. in the context of combinatori auction, the problem of maxim the minimum valu receiv by a player, and comput an envi-minim alloc have been studi briefli. lavi, mu"alem, and nisan [15] show that the former object cannot be implement truthfulli; bezakova and dani [5] gave a 0.5-approxim mechan for two player with addit valuat. lipton et al. [19] show that the latter object cannot be implement truthfulli. these lower bound were strengthen in [20]. 2. preliminari 2.1 the schedul domain in our schedul problem, we ar given n job and m machin, and each job must be assign to exactli on machin. in the unrel-machin set, each machin i is character by a vector of process time (pij)j, where pij ∈ r≥0 ∪ {∞} denot i"s process time for job j with the valu ∞ specifi that i cannot process j. we consid two special case of thi problem: 1. the job-depend two-valu case, where pij ∈ {lj, hj} for everi i, j, with lj ≤ hj, and the valu lj, hj ar known. thi gener the classic  schedul model of restrict machin, where hj = ∞. 2. the two-valu case, which is a special case of abov where lj = l and hj = h for all job j, i.e., pij ∈ {l, h} for everi i, j. we sai that a job j is low on machin i if pij = lj, and high if pij = hj. we will us the term schedul and assign interchang. we repres a determinist schedul by a vector x = (xij)i,j, where xij is 1 if job j is assign to  machin i, thu we have xij ∈ {0, 1} for everi i, j, p i xij = 1 for everi job j. we will also consid random algorithm and algorithm that return a fraction assign. in both these set, we will again specifi an assign by a  vector x = (xij)i,j with p j xij = 1, but now xij ∈ [0, 1] for everi i, j. for a random algorithm, xij is simpli the probabl that j is assign to i (thu, x is a convex  combin of integ assign). we denot the load of machin i (under a given  assign) by li = p j xijpij, and the makespan of a schedul is defin as the maximum load on ani machin, i.e., maxi li. the goal in the makespan-minim problem is to  assign the job to the machin so as to minim the makespan of the schedul. 2.2 mechan design we consid the makespan-minim problem in the abov schedul domain in the context of mechan  design. mechan design studi strateg set where the social design need to ensur the cooper of the  differ entiti involv in the algorithm procedur. follow the work of nisan and ronen [22], we consid the machin to be the strateg player or agent. the social design hold the set of job that need to be assign, but doe 254 not know the (true) process time of these job on the differ machin. each machin is a selfish entiti, that privat know it own process time for each job. on a machin incur a cost to the machin equal to the true  process time of the job on the machin, and a machin mai choos to misrepres it vector of process time, which ar privat, in order to decreas it cost. we consid direct-revel mechan: each machin report it (possibl fals) vector of process time, the mechan then comput a schedul and hand out  payment to the player (i.e., machin) to compens them for the cost thei incur in process their assign job. a (direct-revel) mechan thu consist of a tupl (x, p): x specifi the schedul, and p = {pi} specifi the  payment hand out to the machin, where both x and the pi ar function of the report process time p = (pij)i,j. the mechan"s goal is to comput a schedul that ha near-optim makespan with respect to the true process time; a machin i is howev onli interest in maxim it own util, pi − li, where li is it load under the output assign, and mai declar fals process time if thi could increas it util. the mechan must therefor incentiv the machin/player to truthfulli reveal their process time via the payment. thi is made precis us the notion of domin-strategi truth. definit 2.1 (truth) a schedul mechan is truth if, for everi machin i, everi vector of process time of the other machin, p−i, everi true process-time vector p1 i and ani other vector p2 i of machin i, we have: p1 i − x j x1 ijp1 ij ≥ p2 i − x j x2 ijp1 ij, (1) where (x1 , p1 ) and (x2 , p2 ) ar respect the schedul and payment when the other machin declar p−i and machin i declar p1 i and p2 i , i.e., x1 = x(p1 i , p−i), p1 i = pi(p1 i , p−i) and x2 = x(p2 i , p−i), p2 i = pi(p2 i , p−i). to put it in word, in a truth mechan, no machin can improv it util by declar a fals process time, no matter what the other machin declar. we will also consid fraction mechan that return a fraction assign, and random mechan that ar allow to toss coin and where the assign and the payment mai be random variabl. the notion of  truth for a fraction mechan is the same as in  definit 2.1, where x1 , x2 ar now fraction assign. for a random mechan, we will consid the notion of truth in expect [3], which mean that a  machin (player) maxim her expect util by declar her true process-time vector. inequ (1) also defin truth-in-expect for a random mechan, where p1 i , p2 i now denot the expect payment made to player i, x1 , x2 ar the fraction assign denot the  random algorithm"s schedul (i.e., xk ij is the probabl that j is assign to i in the schedul output for (pk i , p−i)). for our two schedul domain, the inform  assumpt is that the valu lj, hj ar publicli known. the privat inform of a machin is which job have valu lj (or l) and which on have valu hj (or h) on it. we emphas that both of our domain ar multidimension, sinc each machin i need to specifi a vector sai which job ar low and high on it. 3. cycl monoton although truth is defin in term of payment, it turn out that truth actual boil down to a  certain algorithm condit of monoton. thi seem to have been first observ for multidimension domain by rochet [23] in 1987, and ha been us successfulli in  algorithm mechan design sever time, but for  singledimension domain. howev for multidimension  domain, the monoton condit is more involv and there ha been no success in emploi it in the design of  truth mechan. most posit result for multidimension domain have reli on explicit price specif in order to prove truth. on of the main contribut of thi paper is to demonstr that the monoton condit for multidimension set, which is sometim call cycl monoton, can inde be effect util to devis truth mechan. we includ a brief exposit on it for complet. the exposit here is larg base on [11]. cycl monoton is best describ in the abstract social choic set: there is a finit set a of altern, there ar m player, and each player ha a privat type  (valuat function) v : a → r, where vi(a) should be interpret as i"s valu for altern a. in the schedul domain, a repres all the possibl assign of job to machin, and vi(a) is the neg of i"s load in the schedul a. let vi denot the set of all possibl type of player i. a  mechan is a tupl (f, {pi}) where f : v1 × · · · × vm → a is the algorithm for choos the altern, and pi : v1 × · · · × vm → a is the price charg to player i (in the schedul set, the mechan pai the player, which correspond to neg price). the mechan is  truth if for everi i, everi v−i ∈ v−i = q i =i vi , and ani vi, vi ∈ vi we have vi(a) − pi(vi, v−i) ≥ vi(b) − pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i). a basic question that aris is given an algorithm f : v1 × · · · × vm → a, do there exist price that will make the result mechan truth? it is well known (see e.g. [15]) that the price pi can onli depend on the altern chosen and the other" declar, that is, we mai write pi : v−i × a → r. thu, truth impli that for everi i, everi v−i ∈ v−i, and ani vi, vi ∈ vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − pi(a, v−i) ≥ vi(b) − pi(b, v−i). now fix a player i, and fix the declar v−i of the other. we seek an assign to the variabl {pa}a∈a such that vi(a) − vi(b) ≥ pa − pb for everi a, b ∈ a and vi ∈ vi with f(vi, v−i) = a. (strictli speak, we should us a = f(vi, v−i) instead of a here.) defin δa,b := inf{vi(a)− vi(b) : vi ∈ vi, f(vi, v−i) = a}. we can now rephras the abov price-assign problem: we seek an assign to the variabl {pa}a∈a such that pa − pb ≤ δa,b ∀a, b ∈ a (2) thi is easili solv by look at the alloc graph and appli a standard basic result of graph theori. definit 3.1 (gui et al. [11]) the alloc graph of f is a direct weight graph g = (a, e) where e = a × a and the weight of an edg b → a (for ani a, b ∈ a) is δa,b. theorem 3.2 there exist a feasibl assign to (2) iff the alloc graph ha no neg-length cycl.  furthermor, if all cycl ar non-neg, a feasibl assign is 255 obtain as follow: fix an arbitrari node a∗ ∈ a and set pa to be the length of the shortest path from a∗ to a. thi lead to the follow definit, which is anoth wai of phrase the condit that the alloc graph have no neg cycl. definit 3.3 (cycl monoton) a social choic  function f satisfi cycl monoton if for everi player i, everi v−i ∈ v−i, everi integ k, and everi v1 i , . . . , vk i ∈ vi, kx k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ k, and ak+1 = a1. corollari 3.4 there exist price p such that the  mechan (f, p) is truth iff f satisfi cycl monoton.1 we now consid our specif schedul domain. fix a player i, p−i, and ani p1 i , . . . , pk i . let x(pk i , p−i) = xk for 1 ≤ k ≤ k, and let xk+1 = x1 , pk+1 = p1 . xk could be a {0, 1}-assign or a fraction assign. we have vk i (xk ) = − p j xk ijpk ij, so cycl monoton translat to pk k=1 ˆ − p j xk ijpk ij + p j xk+1 ij pk ij ˜ ≥ 0. rearrang, we get kx k=1 x j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. (3) thu (3) reduc our mechan design problem to a concret algorithm problem. for most of thi paper, we will consequ ignor ani strateg consider and  focu on design an approxim algorithm for minim makespan that satisfi (3). 4. a gener techniqu to obtain random mechan in thi section, we consid the case of job-depend lj, hj valu (with lj ≤ hj), which gener the  classic restrict-machin model (where hj = ∞). we show the power of random, by provid a gener  techniqu that convert ani c-approxim algorithm into a 3c-approxim, truth-in-expect mechan. thi is on of the few result that show how to export  approxim algorithm for a multidimension problem into truth mechan when the algorithm is given as a black box. our construct and proof ar simpl, and base on two idea. first, as outlin abov, we prove truth us cycl monoton. it seem unlik that for an arbitrari approxim algorithm given onli as a black box, on would be abl to come up with payment in order to prove truth; but cycl-monoton allow us to prove  precis thi. second, we obtain our random mechan by (a) first move to a fraction domain, and  construct a fraction truth mechan that is allow to return fraction assign; then (b) us a round procedur to express the fraction schedul as a convex combin of integ schedul. thi build upon a theme introduc by lavi and swami [16], name that of us fraction mechan to obtain truth-in-expect mechan. 1 it is not clear if theorem 3.2, and henc, thi statement, hold if a is not finit. we should point out howev that on cannot simpli plug in the result of [16]. their result hold for  social-welfaremaxim problem and reli on us vcg to obtain a fraction truth mechan. vcg howev doe not appli to makespan minim, and in our case even the exist of a near-optim fraction truth mechan is not known. we us the follow result adapt from [16]. lemma 4.1 (lavi and swami [16]) let m = (x, p) be a fraction truth mechan. let a be a random round algorithm that given a fraction assign x, output a random assign x such that e ˆ xij ˜ = xij for all i, j. then there exist payment p such that the  mechan m = (a, p ) is truth in expect. furthermor, if m is individu ration then m is individu ration for everi realiz of coin toss. let opt(p) denot the optim makespan (over integ schedul) for instanc p. as our first step, we take a  capproxim algorithm and convert it to a 2c-approxim fraction truth mechan. thi convers work even when the approxim algorithm return onli a fraction schedul (satisfi certain properti) of makespan at most c · opt(p) for everi instanc p. we prove truth by show that the fraction algorithm satisfi cycl  monoton (3). notic that the altern-set of our fraction mechan is finit (although the set of all fraction  assign is infinit): it cardin is at most that of the  inputdomain, which is at most 2mn in the two-valu case. thu, we can appli corollari 3.4 here. to convert thi fraction truth mechan into a random truth mechan we need a random round procedur satisfi the  requir of lemma 4.1. fortun, such a procedur is alreadi provid by kumar, marath, parthasarathi, and srinivasan [14]. lemma 4.2 (kumar et al. [14]) given a fraction  assign x and a process time vector p, there exist a random round procedur that yield a (random)  assign x such that, 1. for ani i, j, e ˆ xij ˜ = xij. 2. for ani i, p j xijpij < p j xijpij + max{j:xij ∈(0,1)} pij with probabl 1. properti 1 will be us to obtain truth in  expect, and properti 2 will allow us to prove an approxim guarante. we first show that ani algorithm that return a fraction assign have certain properti satisfi cycl monoton. lemma 4.3 let a be an algorithm that for ani input p, output a (fraction) assign x such that, if pij = hj then xij ≤ 1/m, and if pij = lj then xij ≥ 1/m. then a satisfi cycl-monoton. proof. fix a player i, and the vector of process time of the other player p−i. we need to prove (3), that is, pk k=1 p j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for everi p1 i , . . . , pk i , where index k = k + 1 is taken to be k = 1. we will show that for everi job j, pk k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. if pk ij is the same for all k (either alwai lj or alwai hj), then the abov inequ clearli hold. otherwis we can 256 divid the indic 1, . . . , k, into maxim segment, where a maxim segment is a maxim set of consecut indic k , k + 1, . . . , k − 1, k (where k + 1 ≡ 1) such that pk ij = hj ≥ pk +1 ij ≥ · · · ≥ pk ij = lj. thi follow becaus there must be some k such that pk ij = hj > pk−1 ij = lj. we take k = k and then keep includ indic in thi segment till we reach a k such that pk ij = lj and pk+1 ij = hj. we set k = k, and then start a new maxim segment with index k + 1. note that k = k and k + 1 = k − 1. we now have a subset of indic and we can continu recurs. so all indic ar includ in some maxim segment. we will show that for everi such maxim segment k , k +1, . . . , k ,p k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0. ad thi for each segment yield the desir inequ. so now focu on a maxim segment k , k + 1, . . . , k − 1, k . thu, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = hj, and for k∗ ≤ k ≤ k , we have pk ij = lj. now the left hand side of the abov inequ for thi segment is simpli xk ij (lj −hj)+xk∗ ij (hj −lj) ≥ 0, sinc xk ij ≤ 1 m ≤ xk∗ ij as pk ij = hj and pk∗ ij = lj. we now describ how to us a c-approxim algorithm to obtain an algorithm satisfi the properti in lemma 4.3. for simplic, first suppos that the approxim  algorithm return an integr schedul. the idea is to simpli spread thi schedul. we take each job j assign to a high machin and assign it to an extent 1/m on all machin; for each job j assign to a low machin, sai i, we assign 1/m-fraction of it to the other machin where it is low, and assign it remain fraction (which is at least 1/m) to i. the result assign clearli satisfi the desir  properti. also observ that the load on ani machin ha at most increas by 1 m · (load on other machin) ≤ makespan, and henc the makespan ha at most doubl. thi spread out can also be done if the initi schedul is fraction. we now describ the algorithm precis. algorithm 1 let a be ani algorithm that on ani input p output a possibl fraction assign x such that xij > 0 impli that pij ≤ t, where t is the makespan of x. (in particular, note that ani algorithm that return an integr assign ha these properti.) our algorithm, which we call a , return the follow assign xf . initi xf ij = 0 for all i, j. for everi i, j, 1. if pij = hj, set xf ij = p i :pi j =hj xi j/m; 2. if pij = lj, set xf ij = xij + p i =i:pi j =lj (xi j −xij)/m+ p i :pi j =hj xi j/m. theorem 4.4 suppos algorithm a satisfi the condit in algorithm 1 and return a makespan of at most c·opt(p) for everi p. then, the algorithm a construct abov is a 2c-approxim, cycl-monoton fraction algorithm.  moreov, if xf ij > 0 on input p, then pij ≤ c · opt(p). proof. first, note that xf is a valid assign: for everi job j, p i xf ij = p i xij + p i,i =i:pij =pi j =lj (xi j − xij)/m = p i xij = 1. we also have that if pij = hj then xf ij = p i :pi j =hj xi j/m ≤ 1/m. if pij = lj, then xf ij = xij(1 − /m) + p i =i xi j/m where = |{i = i : pi j = lj}| ≤ m − 1; so xf ij ≥ p i xi j/m ≥ 1/m. thu, by lemma 4.3, a satisfi cycl monoton. the total load on ani machin i under xf is at mostp j:pij =hj p i :pi j =hj hj· xi j m + p j:pij =lj lj ` xij+ p i =i xi j m ´ , which is at most p j pijxij + p i =i p j pi jxi j/m ≤ 2c · opt(p). final, if xf ij > 0 and pij = lj, then pij ≤ opt(p). if pij = hj, then for some i (possibl i) with pi j = hj we have xi j > 0, so by assumpt, pi j = hj = pij ≤ c · opt(p). theorem 4.4 combin with lemma 4.1 and 4.2, give a 3c-approxim, truth-in-expect mechan. the comput of payment will depend on the actual  approxim algorithm us. section 3 doe howev give an explicit procedur to comput payment ensur  truth, though perhap not in polynomi-time. theorem 4.5 the procedur in algorithm 1 convert ani c-approxim fraction algorithm into a 3c-approxim, truth-in-expect mechan. take a in algorithm 1 to be the algorithm that return an lp-optimum assign satisfi the requir  condit (see [18, 25]), we obtain a 3-approxim mechan. corollari 4.6 there is a truth-in-expect mechan with approxim ratio 3 for the lj-hj set. 5. a determinist mechan for the two-valu case we now present a determinist 2-approxim truth mechan for the case where pij ∈ {l, h} for all i, j. in the sequel, we will often sai that j is assign to a  lowmachin to denot that j is assign to a machin i where pij = l. we will call a job j a low job of machin i if pij = l; the low-load of i is the load on i due to it low job, i.e., p j:pij =l xijpij. as in section 4, our goal is to obtain an approxim algorithm that satisfi cycl monoton. we first obtain a simplif of condit (3) for our two-valu {l, h} schedul domain (proposit 5.1) that will be conveni to work with. we describ our algorithm in section 5.1. in section 5.2, we bound it approxim guarante and prove that it satisfi cycl-monoton. in section 5.3, we comput explicit payment give a truth mechan. final, in section 5.4 we show that no determinist  mechan can achiev the optimum makespan. defin nk, h = ˛ ˛{j : xk ij = 1, pk ij = l, pij = h} ˛ ˛ (4) nk, l = ˛ ˛{j : xk ij = 1, pk ij = h, pij = l} ˛ ˛. (5) then, p j xk+1 ij (pk ij − pk+1 ij ) = (nk+1,k h − nk+1,k l )(h − l). plug thi into (3) and divid by (h − l), we get the follow. proposit 5.1 cycl monoton in the two-valu  schedul domain is equival to the condit that, for everi player i, everi p−i, everi integ k, and everi p1 i , . . . , pk i , kx k=1 ` nk+1,k h − nk+1,k l ´ ≥ 0. (6) 257 5.1 acycl-monoton approxim algorithm we now describ an algorithm that satisfi condit (6) and achiev a 2-approxim. we will assum that l, h ar integ, which is without loss of gener. a core compon of our algorithm will be a procedur that take an integ load threshold t and comput an integ partial assign x of job to machin such that (a) a job is onli assign to a low machin; (b) the load on ani machin is at most t; and (c) the number of job assign is maxim. such an assign can be comput by solv a max-flow problem: we construct a direct bipartit graph with a node for everi job j and everi machin i, and an edg (j, i) of infinit capac if pij = l. we also add a sourc node s with edg (s, j) have capac 1, and sink node t with edg (i, t) have capac t/l . clearli ani integ flow in thi network correspond to a valid integ partial assign x of makespan at most t, where xij = 1 iff there is a flow of 1 on the edg from j to i. we will therefor us the term assign and flow interchang. moreov, there is alwai an integr max-flow (sinc all capac ar integ). we will often refer to such a max-flow as the max-flow for (p, t). we need on addit concept befor describ the  algorithm. there could potenti be mani max-flow and we will be interest in the most balanc on, which we formal defin as follow. fix some max-flow. let ni p,t be the amount of flow on edg (i, t) (or equival the number of job assign to i in the correspond schedul), and let np,t be the total size of the max-flow, i.e., np,t = p i ni p,t . for ani t ≤ t, defin ni p,t |t = min(ni p,t , t ), that is, we truncat the flow/assign on i so that the total load on i is at most t . defin np,t |t = p i ni p,t |t . we defin a prefix-maxim flow or assign for t as follow. definit 5.2 (prefix-maxim flow) a flow for the abov network with threshold t is prefix-maxim if for everi  integ t ≤ t, we have np,t |t = np,t . that is, in a prefix-maxim flow for (p, t), if we truncat the flow at some t ≤ t, we ar left with a max-flow for (p, t ). an elementari fact about flow is that if an  assign/flow x is not a maximum flow for (p, t) then there must be an augment path p = (s, j1, i1, . . . , jk , ik , t) in the residu graph that allow us to increas the size of the flow. the interpret is that in the current assign, j1 is unassign, xi j = 0, which is denot by the  forward edg (j , i ), and xi j +1 = 1, which is denot by the revers edg (i , j +1). augment x us p chang the assign so that each j is assign to i in the new assign, which increas the valu of the flow by 1. a simpl augment path doe not decreas the load of ani machin; thu, on can argu that a prefix-maxim flow for a threshold t alwai exist. we first comput a max-flow for threshold 1, us simpl augment path to augment it to a max-flow for threshold 2, and repeat, each time augment the max-flow for the previou threshold t to a max-flow for threshold t + 1 us simpl augment path. algorithm 2 given a vector of process time p,  construct an assign of job to machin as follow. 1. comput t∗ (p) = min ˘ t ≥ h, t multipl of l : np,t · l + (n − np,t ) · h ≤ m · t ¯ . note that np,t ·l+(n−np,t )·h −m·t is a decreas function of t, so t∗ (p) can be comput in polynomi time via binari search. 2. comput a prefix-maxim flow for threshold t∗ (p) and the correspond partial assign (i.e., j is  assign to i iff there is 1 unit of flow on edg (j, i)). 3. assign the remain job, i.e., the job unassign in the flow-phase, in a greedi manner as follow.  consid these job in an arbitrari order and assign each job to the machin with the current lowest load (where the load includ the job assign in the flow-phase). our algorithm need to comput a prefix-maxim  assign for the threshold t∗ (p). the proof show the  exist of a prefix-maxim flow onli yield a  pseudopolynomi time algorithm for comput it. but notic that the max-flow remain the same for ani t ≥ t = n · l. so a prefix-maxim flow for t is also prefix-maxim for ani t ≥ t . thu, we onli need to comput a prefix-maxim flow for t = min{t∗ (p), t }. thi can be be done in  polynomi time by us the iter-augment-path  algorithm in the exist proof to comput iter the  maxflow for the polynomi mani multipl of l up to (and includ) t . theorem 5.3 on can effici comput payment that when combin with algorithm 2 yield a determinist  2approxim truth mechan for the two-valu  schedul domain. 5.2 analysi let opt(p) denot the optim makespan for p. we now prove that algorithm 2 is a 2-approxim algorithm that satisfi cycl monoton. thi will then allow us to  comput payment in section 5.3 and prove theorem 5.3. 5.2.1 proof of approxim claim 5.4 if opt(p) < h, the makespan is at most opt(p). proof. if opt(p) < h, it must be that the optim schedul assign all job to low machin, so np,opt(p) = n. thu, we have t∗ (p) = l · h l . furthermor, sinc we comput a prefix-maxim flow for threshold t∗ (p) we have np,t ∗(p)|opt(p) = np,opt(p) = n, which impli that the load on each machin is at most opt(p). so in thi case the makespan is at most (and henc exactli) opt(p). claim 5.5 if opt(p) ≥ h, then t∗ (p) ≤ l · opt(p) l ≤ opt(p) + l. proof. let nopt(p) be the number of job assign to low machin in an optimum schedul. the total load on all machin is exactli nopt(p) · l + (n − nopt(p)) · h, and is at most m · opt(p), sinc everi machin ha load at most opt(p). so take t = l · opt(p) l ≥ h, sinc np,t ≥ nopt(p) we have that np,t ·l+(n−np,t )·h ≤ m·t. henc, t∗ (p), the smallest such t, is at most l · opt(p) l . claim 5.6 each job assign in step 3 of the algorithm is assign to a high machin. 258 proof. suppos j is assign to machin i in step 3. if pij = l, then we must have ni p,t ∗(p) = t∗ (p), otherwis we could have assign j to i in step 2 to obtain a flow of larger valu. so at the point just befor j is assign in step 3, the load of each machin must be at least t∗ (p). henc, the total load after j is assign is at least m · t∗ (p) + l > m · t∗ (p). but the total load is also at most np,t ∗(p) · l + (n − np,t ∗(p)) · h ≤ m · t∗ (p), yield a contradict. lemma 5.7 the abov algorithm return a schedul with makespan at most opt(p)+max ˘ l, h(1− 1 m ) ¯ ≤ 2·opt(p). proof. if opt(p) < h, then by claim 5.4, we ar done. so suppos opt(p) ≥ h. by claim 5.5, we know that t∗ (p) ≤ opt(p) + l. if there ar no unassign job after step 2 of the algorithm, then the makespan is at most t∗ (p) and we ar done. so assum that there ar some unassign job after step 2. we will show that the makespan after step 3 is at most t +h ` 1− 1 m ´ where t = min ˘ t∗ (p), opt(p) ¯ . suppos the claim is fals. let i be the machin with the maximum load, so li > t + h ` 1 − 1 m ´ . let j be the last job assign to i in step 3, and consid the point just befor it is assign to i. so li > t − h/m at thi point. also sinc j is assign to i, by our greedi rule, the load on all the other machin must be at least li. so the total load after j is assign, is at least h + m · li > m · t (sinc pij = h by claim 5.6). also, for ani assign of job to machin in step 3, the total load is at most np,t ∗(p) · l + (n − np,t ∗(p)) · h sinc there ar np,t ∗(p) job assign to low machin. therefor, we must have m · t < np,t ∗(p) · l + (n − np,t ∗(p)) · h. but we will argu that m · t ≥ np,t ∗(p) ·l+(n−np,t ∗(p))·h, which yield a contradict. if t = t∗ (p), thi follow from the definit of t∗ (p). if t = opt(p), then let nopt(p) denot the number of job assign to low machin in an optimum schedul, we have np,t ∗(p) ≥ nopt(p). so np,t ∗(p) ·l+(n−np,t ∗(p))·h ≤ nopt(p) ·l+(n−nopt(p))·h. thi is exactli the total load in an optimum schedul, which is at most m · opt(p). 5.2.2 proof of cycl monoton lemma 5.8 consid ani two instanc p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j. if t is a threshold such that np,t > np ,t , then everi maximum flow x for (p , t) must assign all job j such that pij = l. proof. let gp denot the residu graph for (p , t) and flow x . suppos by contradict that there exist a job j∗ with pij∗ = l that is unassign by x . sinc pi ≥ pi, all edg (j, i) that ar present in the network for (p , t) ar also present in the network for (p, t). thu, x is a valid flow for (p, t). but it is not a max-flow, sinc np,t > np ,t . so there exist an augment path p in the residu graph for (p, t) and flow x . observ that node i must be includ in p, otherwis p would also be an augment path in the residu graph gp contradict the fact that x is a  maxflow. in particular, thi impli that there is a path p ⊂ p from i to the sink t. let p = (i, j1, i1, . . . , jk , ik , t). all the edg of p ar also present as edg in gp - all revers edg (i , j +1) ar present sinc such an edg impli that xi j +1 = 1; all forward edg (j , i ) ar present sinc i = i so pi j = pi j = l, and xi j +1 = 0. but then there is an augment path (j∗ , i, j1, i1, . . . , jk , ik , t) in gp which contradict the maxim of x . let l denot the all-low process time vector. defin tl i (p−i) = t∗ (l, p−i). sinc we ar focus on machin i, and p−i is fix throughout, we abbrevi tl i (p−i) to tl . also, let pl = (l, p−i). note that t∗ (p) ≥ tl for everi instanc p = (pi, p−i). corollari 5.9 let p = (pi, p−i) be ani instanc and let x be ani prefix-maxim flow for (p, t∗ (p)). then, the low-load on machin i is at most tl . proof. let t∗ = t∗ (p). if t∗ = tl , then thi is clearli true. otherwis, consid the assign x truncat at tl . sinc x is prefix-maxim, we know that thi constitut a max-flow for (p, tl ). also, np,t l < npl,t l becaus t∗ > tl . so by lemma 5.8, thi truncat flow must assign all the low job of i. henc, there cannot be a job j with pij = l that is assign to i after the tl -threshold sinc then j would not be assign by thi truncat flow. thu, the low-load of i is at most tl . us these properti, we will prove the follow kei inequ: for ani p1 = (p−i, p1 i ) and p2 = (p−i, p2 i ), np1,t l ≥ np2,t l − n2,1 h + n2,1 l (7) where n2,1 h and n2,1 l ar as defin in (4) and (5),  respect. notic that thi immedi impli cycl  monoton, sinc if we take p1 = pk and p2 = pk+1 , then (7) impli that npk,t l ≥ npk+1,t l − nk+1,k h + nk+1,k l ; sum thi over all k = 1, . . . , k give (6). lemma 5.10 if t∗ (p1 ) > tl , then (7) hold. proof. let t1 = t∗ (p1 ) and t2 = t∗ (p2 ). take the prefix-maxim flow x2 for (p2 , t2 ), truncat it at tl , and remov all the job from thi assign that ar count in n2,1 h , that is, all job j such that x2 ij = 1, p2 ij = l, p1 ij = h. denot thi flow by x. observ that x is a valid flow for (p1 , tl ), and the size of thi flow is exactli np2,t 2 |t l −n2,1 h = np2,t l −n2,1 h . also none of the job that ar count in n2,1 l ar assign by x sinc each such job j is high on i in p2 . sinc t1 > tl , we must have np1,t l < npl,t l . so if we augment x to a max-flow for (p1 , tl ), then by lemma 5.8 (with p = pl and p = p1 ), all the job correspond to n2,1 l must be assign in thi max-flow. thu, the size of thi max-flow is at least (size of x) + n2,1 l , that is, np1,t l ≥ np2,t l − n2,1 h + n2,1 l , as claim. lemma 5.11 suppos t∗ (p1 ) = tl . then (7) hold. proof. again let t1 = t∗ (p1 ) = tl and t2 = t∗ (p2 ). let x1 , x2 be the complet assign, i.e., the assign after both step 2 and 3, comput by our algorithm for p1 , p2 respect. let s = {j : x2 ij = 1 and p2 ij = l} and s = {j : x2 ij = 1 and p1 ij = l}. therefor, |s | = |s| − n2,1 h + n2,1 l and |s| = ni p2,t 2 = ni p2,t 2 |t l (by corollari 5.9). let t = |s | · l. we consid two case. suppos first that t ≤ tl . consid the follow flow for (p1 , tl ): assign to everi machin other than i the  lowassign of x2 truncat at tl , and assign the job in s to machin i. thi is a valid flow for (p1 , tl ) sinc the load on i is t ≤ tl . it size is equal to p i =i ni p2,t 2 |t l +|s | = np2,t 2 |t l −n2,1 h +n2,1 l = np2,t l −n2,1 h +n2,1 l . the size of the max-flow for (p1 , tl ) is no smaller, and the claim follow. 259 now suppos t > tl . sinc |s| · l ≤ tl (by  corollari 5.9), it follow that n2,1 l > n2,1 h ≥ 0. let ˆt = t − l ≥ tl sinc t , tl ar both multipl of l. let m = np2,t 2 − n2,1 h + n2,1 l = |s | + p i =i ni p2,t 2 . we first show that m · ˆt < m · l + (n − m) · h. (8) let n be the number of job assign to machin i in x2 . the load on machin i is |s|·l+(n −|s|)·h ≥ |s |·l−n2,1 l · l+(n−|s|)·h which is at least |s |·l > ˆt sinc n2,1 l ≤ n− |s|. thu we get the inequ |s |·l+(n −|s |)·h > ˆt. now consid the point in the execut of the algorithm on instanc p2 just befor the last high job is assign to i in step 3 (there must be such a job sinc n2,1 l > 0). the load on i at thi point is |s| · l + (n − |s| − 1) · h which is least |s | · l − l = ˆt by a similar argument as abov. by the greedi properti, everi i = i also ha at least thi load at thi point, so p j p2 i jx2 i j ≥ ˆt. ad these inequ for all i = i, and the earlier inequ for i, we get that |s | · l + (n − |s |) · h + p i =i p j p2 i jx2 i j > m ˆt. but the left-hand-side is exactli m · l + (n − m) · h. on the other hand, sinc t1 = tl , we have m · ˆt ≥ m · tl ≥ np1,t l · l + (n − np1,t l ) · h. (9) combin (8) and (9), we get that np1,t l > m = np2,t 2 − n2,1 h + n2,1 l ≥ np2,t l − n2,1 h + n2,1 l . lemma 5.12 algorithm 2 satisfi cycl monoton. proof. take p1 = pk and p2 = pk+1 in (7), we get that npk,t l ≥ npk+1,t l −nk+1,k h +nk+1,k l . sum thi over all k = 1, . . . , k (where k + 1 ≡ 1) yield (6). 5.3 comput of price lemma 5.7 and 5.12 show that our algorithm is a  2approxim algorithm that satisfi cycl monoton. thu, by the discuss in section 3, there exist price that yield a truth mechan. to obtain a polynomi-time mechan, we also need to show how to comput these price (or payment) in polynomi-time. it is not clear, if the procedur outlin in section 3 base on comput shortest path in the alloc graph yield a polynomi time algorithm, sinc the alloc graph ha an  exponenti number of node (on for each output assign).  instead of analyz the alloc graph, we will leverag our proof of cycl monoton, in particular, inequ (7), and simpli spell out the payment. recal that the util of a player is ui = pi − li, where pi is the payment made to player i. for conveni, we will first specifi neg payment (i.e., the pi will actual be price charg to the player) and then show that these can be modifi so that player have non-neg util (if thei act truthfulli). let hi denot the number of job assign to machin i in step 3. by corollari 5.6, we know that all these job ar assign to high machin (accord to the declar pi). let h−i = p i =i hi and n−i p,t = p i =i ni p,t . the payment pi to player i is defin as: pi(p) = −l · n−i p,t ∗(p) − h · h−i (p) − (h − l) ` np,t ∗(p) − np,t l i (p−i) ´ (10) we can interpret our payment as equat the player"s cost to a care modif of the total load (in the spirit of vcg price). the first and second term in (10), when  subtract from i"s load li equat i"s cost to the total load. the term np,t ∗(p) − np,t l i (p−i) is in fact equal to n−i p,t ∗(p) − n−i p,t ∗(p)|t l i (p−i) sinc the low-load on i is at most tl i (p−i) (by claim 5.9). thu the last term in equat (10) impli that we treat the low job that were assign beyond the tl i (p−i) threshold (to machin other than i) effect as high job for the total util calcul from i"s point of view. it is not clear how on could have conjur up these payment a priori in order to prove the truth of our algorithm. howev, by reli on cycl monoton, we were not onli abl to argu the exist of payment, but also our proof pave the wai for actual infer these  payment. the follow lemma explicitli verifi that the  payment defin abov do inde give a truth mechan. lemma 5.13 fix a player i and the other player"  declar p−i. let i"s true type be p1 i . then, under the payment defin in (10), i"s util when she declar her true type p1 i is at least her util when she declar ani other type p2 i . proof. let c1 i , c2 i denot i"s total cost, defin as the neg of her util, when she declar p1 , and p2 ,  respect (and the other declar p−i). sinc p−i is fix, we omit p−i from the express below for notat clariti. the true load of i when she declar her true type p1 i is l · ni p1,t ∗(p1) + h · hi (p1 ), and therefor c1 i = l · np1,t ∗(p1) + h · (n − np1,t ∗(p1)) + (h − l) ` np1,t ∗(p1) − np1,t l i ´ = n · h − (h − l)np1,t l i (11) on the other hand, i"s true load when she declar p2 i is l · (ni p2,t ∗(p2) − n2,1 h + n2,1 l ) + h · (hi + n2,1 h − n2,1 l ) (sinc i"s true process time vector is p1 i ), and thu c2 i = n · h − (h − l)np2,t l i + (h − l)n2,1 h − (h − l)n2,1 l . thu, (7) impli that c1 i ≤ c2 i . price specif ar commonli requir to satisfi, in addit to truth, individu ration, i.e., a player"s util should be non-neg if she reveal her true valu. the payment given by (10) ar not individu ration as thei actual charg a player a certain amount. howev, it is well-known that thi problem can be easili solv by ad a larg-enough constant to the price definit. in our case, for exampl, let h denot the vector of all h"s, we can add the term n·h −(h −l)n(h,p−i),t l i (p−i) to (10). note that thi is a constant for player i. thu, the new payment ar pi (p) = n · h − l · n−i p,t ∗(p) − h · h−i (p) − (h −l) ` np,t ∗(p) −np,t l i (p−i) +n(h,p−i),t l i (p−i) ´ . as shown by (11), thi will inde result in a non-neg util for i (sinc n(h,p−i),t l i (p−i) ≤ n(pi,p−i),t l i (p−i) for ani type pi of player i). thi modif also ensur the addition desir normal properti that if a player receiv no job then she receiv zero payment: if player i receiv the empti set for some type pi then she will also receiv the empti set for the type h (thi is easi to verifi for our  specif algorithm), and for the type h, her util equal zero; thu, by truth thi must also be the util of everi other declar that result in i receiv the empti set. thi complet the proof of theorem 5.3. 260 5.4 imposs of exact implement we now show that irrespect of comput  consider, there doe not exist a cycl-monoton algorithm for the l-h case with an approxim ratio better than 1.14. let h = α·l for some 2 < α < 2.5 that we will choos later. there ar two machin i, ii and seven job. consid the follow two scenario: scenario 1. everi job ha the same process time on both machin: job 1-5, ar l, and job 6, 7 ar h. ani optim schedul assign job 1-5 to on machin and job 6, 7 to the other, and ha makespan opt1 = 5l. the  secondbest schedul ha makespan at least second1 = 2h + l. scenario 2. if the algorithm choos an optim schedul for scenario 1, assum without loss of gener that job 6, 7 ar assign to machin ii. in scenario 2, machin i ha the same process-time vector. machin ii lower job 6, 7 to l and increas 1-5 to h. an optim schedul ha makespan 2l + h, where machin ii get job 6, 7 and on of the job 1-5. the second-best schedul for thi scenario ha makespan at least second2 = 5l. theorem 5.14 no determinist truth mechan for the two-valu schedul problem can obtain an approxim ratio better than 1.14. proof. we first argu that a cycl-monoton algorithm cannot choos the optim schedul in both scenario. thi follow becaus otherwis cycl monoton is violat for machin ii. take p1 ii , p2 ii to be machin ii"s  processingtim vector for scenario 1, 2 respect, we get p j(p1 ii ,j − p2 ii ,j)(x2 ii ,j −x1 ii ,j) = (l−h)(1−0) < 0. thu, ani truth mechan must return a sub-optim makespan in at least on scenario, and therefor it approxim ratio is at least min ˘second1 opt1 , second2 opt2 ¯ ≥ 1.14 for α = 2.364. we remark that for the {lj, hj}-case where there is a common ratio r = hj lj for all job (thi gener the restrict-machin set) on can obtain a fraction  truth mechan (with effici comput price) that  return a schedul of makespan at most opt(p) for everi p. on can view each job j as consist of lj sub-job of size 1 on a machin i if pij = lj, and size r if pij = hj. for thi new instanc ˜p, note that ˜pij ∈ {1, r} for everi i, j. notic also that ani assign ˜x for the instanc ˜p translat to a fraction assign x for p, where pijxij =p j : sub-job of j ˜pij ˜xij . thu, if we us algorithm 2 to  obtain a schedul for the instanc ˜p, equat (6) translat precis to (3) for the assign x; moreov, the price for ˜p translat to price for the instanc p. the number of sub-job assign to low-machin in the flow-phase is  simpli the total work assign to low-machin. thu, we can implement the abov reduct by set up a max-flow problem that seem to maxim the total work assign to low machin. moreov, sinc we have a fraction  domain, we can us a more effici greedi rule for pack the unassign portion of job and argu that the fraction  assign ha makespan at most opt(p). the assign x need not howev satisfi the condit that xij > 0  impli pij ≤ opt(p) for arbitrari r, therefor, the round procedur of lemma 4.2 doe not yield a 2-approxim truth-in-expect mechan. but if r > opt(p) (as in the restrict-machin set), thi condit doe hold, so we get a 2-approxim truth mechan. acknowledg we thank elia koutsoupia for hi help in refin the  analysi of the lower bound in section 5.4, and the review for their help comment. 6. refer [1] n. andelman, y. azar, and m. sorani. truth approxim mechan for schedul selfish relat machin. in proc. 22nd stac, 69-82, 2005. [2] a. archer. mechan for discret optim with ration agent. phd thesi, cornel univers, 2004. [3] a. archer and ´e. tardo. truth mechan for on-paramet agent. in proc. 42nd foc, page 482-491, 2001. [4] v. auletta, r. de-prisco, p. penna, and g. persiano. determinist truth approxim mechan for schedul relat machin. in proc. 21st stac, page 608-619, 2004. [5] i. bez´akov´a and v. dani. alloc indivis good. in acm sigecom exchang, 2005. [6] s. bikhchandani, s. chatterje, r. lavi, a. mu"alem, n. nisan, and a. sen. weak monoton character determinist domin-strategi implement. econometrica, 74:1109-1132, 2006. [7] p. briest, p. krysta, and b. vock. approxim techniqu for utilitarian mechan design. in proc. 37th stoc, page 39-48, 2005. [8] g. christodoul, e. koutsoupia, and a. vidali. a lower bound for schedul mechan. in proc. 18th soda, page 1163-1170, 2007. [9] e. clark. multipart price of public good. public choic, 8:17-33, 1971. [10] t. grove. incent in team. econometrica, 41:617-631, 1973. [11] h. gui, r. muller, and r. v. vohra. character domin strategi mechan with multi-dimension type, 2004. work paper. [12] l. a. hall. approxim algorithm for schedul. in d. hochbaum, editor, approxim algorithm for np-hard problem. pw publish, ma, 1996. [13] a. kov´ac. fast monoton 3-approxim algorithm for schedul relat machin. in proc. 13th esa, page 616-627, 2005. [14] v. s. a. kumar, m. v. marath, s. parthasarathi, and a. srinivasan. approxim algorithm for schedul on multipl machin. in proc. 46th foc, page 254-263, 2005. [15] r. lavi, a. mu"alem, and n. nisan. toward a character of truth combinatori auction. in proc. 44th foc, page 574-583, 2003. [16] r. lavi and c. swami. truth and near-optim mechan design via linear program. in proc. 46th foc, page 595-604, 2005. [17] d. lehmann, l. o"callaghan, and y. shoham. truth revel in approxim effici combinatori auction. journal of the acm, 49:577-602, 2002. [18] j. k. lenstra, d. b. shmoi, and ´e. tardo. approxim algorithm for schedul unrel parallel machin. math. prog., 46:259-271, 1990. [19] r. j. lipton, e. markaki, e. mossel, and a. saberi. on approxim fair alloc of indivis good. in proc. 5th ec, page 125-131, 2004. [20] a. mu"alem and m. schapira. set lower bound on truth. in proc. 18th soda, 1143-1152, 2007. [21] r. myerson. optim auction design. mathemat of oper research, 6:58-73, 1981. [22] n. nisan and a. ronen. algorithm mechan design. game and econ. behavior, 35:166-196, 2001. [23] j. c. rochet. a necessari and suffici condit for rationaliz in a quasilinear context. journal of mathemat econom, 16:191-200, 1987. [24] m. sak and l. yu. weak monoton suffic for truth on convex domain. in proc. 6th ec, page 286-293, 2005. [25] d. b. shmoi and ´e. tardo. an approxim algorithm for the gener assign problem. mathemat program, 62:461-474, 1993. [26] w. vickrei. counterspecul, auction, and competit seal tender. j. financ, 16:8-37, 1961. 261 