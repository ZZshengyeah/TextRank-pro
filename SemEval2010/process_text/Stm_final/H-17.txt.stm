prune polici for two-tier invert index with correct guarante alexandro ntoula∗ microsoft search lab 1065 la avenida mountain view, ca 94043, usa antoula@microsoft.com junghoo cho† ucla comput scienc dept. boelter hall lo angel, ca 90095, usa cho@cs.ucla.edu abstract the web search engin maintain larg-scale invert index which ar queri thousand of time per second by user eager for inform. in order to cope with the vast amount of queri load, search engin prune their index to keep document that ar like to be return as top result, and us thi prune index to comput the first batch of result. while thi approach can  improv perform by reduc the size of the index, if we comput the top result onli from the prune index we mai notic a  signific degrad in the result qualiti: if a document should be in the top result but wa not includ in the prune index, it will be place behind the result comput from the prune index. given the fierc competit in the onlin search market, thi phenomenon is clearli undesir. in thi paper, we studi how we can avoid ani degrad of result qualiti due to the prune-base perform optim, while still realiz most of it benefit. our contribut is a  number of modif in the prune techniqu for creat the prune index and a new result comput algorithm that  guarante that the top-match page ar alwai place at the top search result, even though we ar comput the first batch from the prune index most of the time. we also show how to determin the optim size of a prune index and we experiment evalu our algorithm on a collect of 130 million web page. categori and subject descriptor h.3.1 [inform storag and retriev]: content analysi and index; h.3.3 [inform storag and retriev]:  inform search and retriev gener term algorithm, measur, perform, design, experiment 1. introduct the amount of inform on the web is grow at a prodigi rate [24]. accord to a recent studi [13], it is estim that the web current consist of more than 11 billion page. due to thi immens amount of avail inform, the user ar becom more and more depend on the web search engin for locat relev inform on the web. typic, the web search  engin, similar to other inform retriev applic, util a data structur call invert index. an invert index provid for the effici retriev of the document (or web page) that contain a particular keyword. in most case, a queri that the user issu mai have thousand or even million of match document. in order to avoid  overwhelm the user with a huge amount of result, the search  engin present the result in batch of 10 to 20 relev document. the user then look through the first batch of result and, if she doesn"t find the answer she is look for, she mai potenti  request to view the next batch or decid to issu a new queri. a recent studi [16] indic that approxim 80% of the user examin at most the first 3 batch of the result. that is, 80% of the user typic view at most 30 to 60 result for everi queri that thei issu to a search engin. at the same time, given the size of the web, the invert index that the search engin maintain can grow veri larg. sinc the user ar interest in a small  number of result (and thu ar view a small portion of the index for everi queri that thei issu), us an index that is capabl of  return all the result for a queri mai constitut a signific wast in term of time, storag space and comput resourc, which is bound to get wors as the web grow larger over time [24]. on natur solut to thi problem is to creat a small index on a subset of the document that ar like to be return as the top  result (by us, for exampl, the prune techniqu in [7, 20]) and comput the first batch of answer us the prune index. while thi approach ha been shown to give signific improv in perform, it also lead to notic degrad in the qualiti of the search result, becaus the top answer ar comput onli from the prune index [7, 20]. that is, even if a page should be place as the top-match page accord to a search engin"s rank  metric, the page mai be place behind the on contain in the prune index if the page did not becom part of the prune index for  variou reason [7, 20]. given the fierc competit among search engin todai thi degrad is clearli undesir and need to be address if possibl. in thi paper, we studi how we can avoid ani degrad of search qualiti due to the abov perform optim while still realiz most of it benefit. that is, we present a number of simpl (yet import) chang in the prune techniqu for  creat the prune index. our main contribut is a new answer comput algorithm that guarante that the top-match page (accord to the search-engin"s rank metric) ar alwai place at the top of search result, even though we ar comput the first batch of answer from the prune index most of the time. these enhanc prune techniqu and answer-comput algorithm ar explor in the context of the cluster architectur commonli emploi by todai"s search engin. final, we studi and present how search engin can minim the oper cost of answer queri while provid high qualiti search result. if if if if if if if ip ip ip ip ip ip 5000 queri/sec 5000 queri/sec : 1000 queri/sec : 1000 queri/sec 2nd tier 1st tier (a) (b) figur 1: (a) search engin replic it full index if to  increas queri-answer capac. (b) in the 1st tier, small  pindex ip handl most of the queri. when ip cannot answer a queri, it is redirect to the 2nd tier, where the full index if is us to comput the answer. 2. cluster architectur and cost save from a prune index typic, a search engin download document from the web and maintain a local invert index that is us to answer queri quickli. invert index. assum that we have collect a set of  document d = {d1, . . . , dm } and that we have extract all the term t = {t1, . . . , tn} from the document. for everi singl term ti ∈ t we maintain a list i(ti) of document id that contain ti. everi entri in i(ti) is call a post and can be extend to includ addit inform, such as how mani time ti appear in a document, the posit of ti in the document, whether ti is bold/ital, etc. the set of all the list i = {i(t1), . . . , i(tn)} is our invert index. 2.1 two-tier index architectur search engin ar accept an enorm number of queri everi dai from eager user search for relev inform. for exampl, googl is estim to answer more than 250 million user queri per dai. in order to cope with thi huge queri load, search engin typic replic their index across a larg cluster of  machin as the follow exampl illustr: exampl 1 consid a search engin that maintain a cluster of machin as in figur 1(a). the size of it full invert index if is larger than what can be store in a singl machin, so each copi of if is store across four differ machin. we also suppos that on copi of if can handl the queri load of 1000 queri/sec. assum that the search engin get 5000 queri/sec, it need to replic if five time to handl the load. overal, the search engin need to maintain 4 × 5 = 20 machin in it cluster. 2 while fulli replic the entir index if multipl time is a straightforward wai to scale to a larg number of queri, typic queri load at search engin exhibit certain local, allow for signific reduct in cost by replic onli a small portion of the full index. in principl, thi is typic done by prune a full index if to creat a smaller, prune index (or p-index) ip , which contain a subset of the document that ar like to be return as top result. given the p-index, search engin oper by emploi a  twotier index architectur as we show in figur 1(b): all incom queri ar first direct to on of the p-index kept in the 1st tier. in the case where a p-index cannot comput the answer (e.g. wa unabl to find enough document to return to the user) the queri is answer by redirect it to the 2nd tier, where we maintain a full index if . the follow exampl illustr the potenti reduct in the queri-process cost by emploi thi two-tier index architectur. exampl 2 assum the same paramet set as in exampl 1. that is, the search engin get a queri load of 5000 queri/sec algorithm 2.1 comput of answer with correct guarante input q = ({t1, . . . , tn}, [i, i + k]) where {t1, . . . , tn}: keyword in the queri [i, i + k]: rang of the answer to return procedur (1) (a, c) = computeansw(q, ip ) (2) if (c = 1) then (3) return a (4) els (5) a = computeansw(q, if ) (6) return a figur 2: comput the answer under the two-tier  architectur with the result correct guarante. and everi copi of an index (both the full if and p-index ip ) can handl up to 1000 queri/sec. also assum that the size of ip is on fourth of if and thu can be store on a singl machin.  final, suppos that the p-index can handl 80% of the user queri by themselv and onli forward the remain 20% queri to if . under thi set, sinc all 5000/sec user queri ar first direct to a p-index, five copi of ip ar need in the 1st tier. for the 2nd tier, sinc 20% (or 1000 queri/sec) ar forward, we need to maintain on copi of if to handl the load. overal we need a total of 9 machin (five machin for the five copi of ip and four machin for on copi of if ). compar to exampl 1, thi is more than 50% reduct in the number of machin. 2 the abov exampl demonstr the potenti cost save achiev by us a p-index. howev, the two-tier architectur mai have a signific drawback in term of it result qualiti  compar to the full replic of if ; given the fact that the p-index contain onli a subset of the data of the full index, it is possibl that, for some queri, the p-index mai not contain the top-rank  document accord to the particular rank criteria us by the search engin and fail to return it as the top page, lead to notic qualiti degrad in search result. given the fierc competit in the onlin search market, search engin oper desper try to avoid ani reduct in search qualiti in order to maxim user satisfact. 2.2 correct guarante under two-tier architectur how can we avoid the potenti degrad of search qualiti under the two-tier architectur? our basic idea is straightforward: we us the top-k result from the p-index onli if we know for sure that the result is the same as the top-k result from the full index. the algorithm in figur 2 formal thi idea. in the algorithm, when we comput the result from ip (step 1), we comput not onli the top-k result a, but also the correct indic function c defin as follow: definit 1 (correct indic function) given a queri q, the p-index ip return the answer a togeth with a correct indic function c. c is set to 1 if a is guarante to be ident (i.e. same result in the same order) to the result comput from the full index if . if it is possibl that a is differ, c is set to 0. 2 note that the algorithm return the result from ip (step 3) onli when it is ident to the result from if (condit c = 1 in step 2). otherwis, the algorithm recomput and return the  result from the full index if (step 5). therefor, the algorithm is guarante to return the same result as the full replic of if all the time. now, the real challeng is to find out (1) how we can comput the correct indic function c and (2) how we should prune the index to make sure that the major of queri ar handl by ip alon. question 1 how can we comput the correct indic  function c? a straightforward wai to calcul c is to comput the top-k  answer both from ip and if and compar them. thi naiv solut, howev, incur a cost even higher than the full replic of if becaus the answer ar comput twice: onc from ip and onc from if . is there ani wai to comput the correct indic function c onli from ip without comput the answer from if ? question 2 how should we prune if to ip to realiz the maximum cost save? the effect of algorithm 2.1 critic depend on how often the correct indic function c is evalu to be 1. if c = 0 for all queri, for exampl, the answer to all queri will be comput twice, onc from ip (step 1) and onc from if (step 5), so the perform will be wors than the full replic of if . what will be the optim wai to prune if to ip , such that c = 1 for a larg fraction of queri? in the next few section, we try to address these question. 3. optim size of the p-index intuit, there exist a clear tradeoff between the size of ip and the fraction of queri that ip can handl: when ip is larg and ha more inform, it will be abl to handl more queri, but the cost for maintain and look up ip will be higher. when ip is small, on the other hand, the cost for ip will be smaller, but more queri will be forward to if , requir us to maintain more copi of if . given thi tradeoff, how should we determin the optim size of ip in order to maxim the cost save? to find the answer, we start with a simpl exampl. exampl 3 again, consid a scenario similar to exampl 1, where the queri load is 5000 queri/sec, each copi of an index can handl 1000 queri/sec, and the full index span across 4  machin. but now, suppos that if we prune if by 75% to ip 1 (i.e., the size of ip 1 is 25% of if ), ip 1 can handl 40% of the queri (i.e., c = 1 for 40% of the queri). also suppos that if if is prune by 50% to ip 2, ip 2 can handl 80% of the queri. which on of the ip 1, ip 2 is prefer for the 1st -tier index? to find out the answer, we first comput the number of machin need when we us ip 1 for the 1st tier. at the 1st tier, we need 5 copi of ip 1 to handl the queri load of 5000 queri/sec. sinc the size of ip 1 is 25% of if (that requir 4 machin), on copi of ip 1 requir on machin. therefor, the total number of machin requir for the 1st tier is 5×1 = 5 (5 copi of ip 1 with 1 machin per copi). also, sinc ip 1 can handl 40% of the queri, the 2nd tier ha to handl 3000 queri/sec (60% of the 5000 queri/sec), so we need a total of 3×4 = 12 machin for the 2nd tier (3 copi of if with 4 machin per copi). overal, when we us ip 1 for the 1st tier, we need 5 + 12 = 17 machin to handl the load. we can do similar analysi when we us ip 2 and see that a total of 14 machin ar need when ip 2 is us. given thi result, we can conclud that us ip 2 is prefer. 2 the abov exampl show that the cost of the two-tier  architectur depend on two import paramet: the size of the p-index and the fraction of the queri that can be handl by the 1st tier index alon. we us s to denot the size of the p-index rel to if (i.e., if s = 0.2, for exampl, the p-index is 20% of the size of if ). we us f(s) to denot the fraction of the queri that a p-index of size s can handl (i.e., if f(s) = 0.3, 30% of the queri return the valu c = 1 from ip ). in gener, we can expect that f(s) will increas as s get larger becaus ip can handl more queri as it size grow. in figur 3, we show an exampl graph of f(s) over s. given the notat, we can state the problem of p-index-size  optim as follow. in formul the problem, we assum that the number of machin requir to oper a two-tier architectur 0 0.2 0.4 0.6 0.8 1 0 0.2 0.4 0.6 0.8 1 fractionofqueriesguarante-f(s) fraction of index - s fraction of queri guarante per fraction of index optim size s=0.16 figur 3: exampl function show the fraction of guarante queri f(s) at a given size s of the p-index. is roughli proport to the total size of the index necessari to handl the queri load. problem 1 (optim index size) given a queri load q and the function f(s), find the optim p-index size s that minim the total size of the index necessari to handl the load q. 2 the follow theorem show how we can determin the optim index size. theorem 1 the cost for handl the queri load q is minim when the size of the p-index, s, satisfi d f(s) d s = 1. 2 proof the proof of thi and the follow theorem is omit due to space constraint. thi theorem show that the optim point is when the slope of the f(s) curv is 1. for exampl, in figur 3, the optim size is when s = 0.16. note that the exact shape of the f(s) graph mai vari depend on the queri load and the prune polici. for exampl, even for the same p-index, if the queri load chang  significantli, fewer (or more) queri mai be handl by the p-index, decreas (or increas)f(s). similarli, if we us an effect prune polici, more queri will be handl by ip than when we us an ineffect prune polici, increas f(s). therefor, the function f(s) and the optim-index size mai chang significantli depend on the queri load and the prune polici. in our later  experi, howev, we find that even though the shape of the f(s) graph chang notic between experi, the optim index size consist li between 10%-30% in most experi. 4. prune polici in thi section, we show how we should prune the full index if to ip , so that (1) we can comput the correct indic function c from ip itself and (2) we can handl a larg fraction of queri by ip . in design the prune polici, we note the follow two local in the user" search behavior: 1. keyword local: although there ar mani differ word in the document collect that the search engin index, a few popular keyword constitut the major of the queri load. thi keyword local impli that the search engin will be abl to answer a signific fraction of user queri even if it can handl onli these few popular keyword. 2. document local: even if a queri ha million of  match document, user typic look at onli the first few  result [16]. thu, as long as search engin can comput the first few top-k answer correctli, user often will not notic that the search engin actual ha not comput the correct answer for the remain result (unless the user explicitli request them). base on the abov two local, we now investig two  differ type of prune polici: (1) a keyword prune polici, which take advantag of the keyword local by prune the whole  invert list i(ti) for unpopular keyword ti"s and (2) a document prune polici, which take advantag of the document local by keep onli a few post in each list i(ti), which ar like to be includ in the top-k result. as we discuss befor, we need to be abl to comput the  correct indic function from the prune index alon in order to provid the correct guarante. sinc the comput of  correct indic function mai critic depend on the particular rank function us by a search engin, we first clarifi our  assumpt on the rank function. 4.1 assumpt on rank function consid a queri q = {t1, t2, . . . , tw} that contain a subset of the index term. the goal of the search engin is to return the document that ar most relev to queri q. thi is done in two step: first we us the invert index to find all the document that contain the term in the queri. second, onc we have the  relev document, we calcul the rank (or score) of each on of the document with respect to the queri and we return to the user the document that rank the highest. most of the major search engin todai return document  contain all queri term (i.e. thei us and-semant). in order to make our discuss more concis, we will also assum the  popular and-semant while answer a queri. it is straightforward to extend our result to or-semant as well. the exact rank function that search engin emploi is a close guard secret. what is known, howev, is that the factor in determin the  document rank can be roughli categor into two class: queri-depend relev. thi particular factor of relev captur how relev the queri is to everi document. at a high level, given a document d, for everi term ti a search engin assign a term relev score tr(d, ti) to d. given the tr(d, ti) score for everi ti, then the queri-depend relev of d to the queri, note as tr(d, q), can be comput by combin the individu term relev valu. on popular wai for calcul the  querydepend relev is to repres both the document d and the queri q us the tf.idf vector space model [29] and emploi a cosin distanc metric. sinc the exact form of tr(d, ti) and tr(d, q) differ  depend on the search engin, we will not restrict to ani particular form; instead, in order to make our work applic in the gener case, we will make the gener assumpt that the queri-depend  relev is comput as a function of the individu term relev valu in the queri: tr(d, q) = ftr(tr(d, t1), . . . , tr(d, tw)) (1) queri-independ document qualiti. thi is a factor that  measur the overal qualiti of a document d independ of the  particular queri issu by the user. popular techniqu that comput the gener qualiti of a page includ pagerank [26], hit [17] and the likelihood that the page is a spam page [25, 15]. here, we will us pr(d) to denot thi queri-independ part of the final rank function for document d. the final rank score r(d, q) of a document will depend on both the queri-depend and queri-independ part of the  rank function. the exact combin of these part mai be done in a varieti of wai. in gener, we can assum that the final  rank score of a document is a function of it queri-depend and queri-independ relev score. more formal: r(d, q) = fr(tr(d, q), pr(d)) (2) for exampl, fr(tr(d, q), pr(d)) mai take the form fr(tr(d, q), pr(d)) = α · tr(d, q) + (1 − α) · pr(d), thu give weight α to the queri-depend part and the weight 1 − α to the queri-independ part. in equat 1 and 2 the exact form of fr and ftr can vari  depend on the search engin. therefor, to make our discuss applic independ of the particular rank function us by search engin, in thi paper, we will make onli the gener  assumpt that the rank function r(d, q) is monoton on it  paramet tr(d, t1), . . . , tr(d, tw) and pr(d). t1 → d1 d2 d3 d4 d5 d6 t2 → d1 d2 d3 t3 → d3 d5 d7 d8 t4 → d4 d10 t5 → d6 d8 d9 figur 4: keyword and document prune. algorithm 4.1 comput of c for keyword prune procedur (1) c = 1 (2) foreach ti ∈ q (3) if (i(ti) /∈ ip ) then c = 0 (4) return c figur 5: result guarante in keyword prune. definit 2 a function f(α, β, . . . , ω) is monoton if ∀α1 ≥ α2, ∀β1 ≥ β2, . . . ∀ω1 ≥ ω2 it hold that: f(α1, β1, . . . , ω1) ≥ f(α2, β2, . . . , ω2). roughli, the monoton of the rank function impli that, between two document d1 and d2, if d1 ha higher  querydepend relev than d2 and also a higher queri-independ score than d2, then d1 should be rank higher than d2, which we believ is a reason assumpt in most practic set. 4.2 keyword prune given our assumpt on the rank function, we now  investig the keyword prune polici, which prune the invert index if horizont by remov the whole i(ti)"s correspond to the least frequent term. in figur 4 we show a graphic  represent of keyword prune, where we remov the invert list for t3 and t5, assum that thei do not appear often in the queri load. note that after keyword prune, if all keyword {t1, . . . , tn} in the queri q appear in ip , the p-index ha the same inform as if as long as q is concern. in other word, if all keyword in q appear in ip , the answer comput from ip is guarante to be the same as the answer comput from if . figur 5 formal thi observ and comput the correct indic function c for a keyword-prune index ip . it is straightforward to prove that the answer from ip is ident to that from if if c = 1 in the abov algorithm. we now consid the issu of optim the ip such that it can handl the largest fraction of queri. thi problem can be formal state as follow: problem 2 (optim keyword prune) given the queri load q and a goal index size s · |if | for the prune index, select the  invert list ip = {i(t1), . . . , i(th)} such that |ip | ≤ s · |if | and the fraction of queri that ip can answer (express by f(s)) is maxim. 2 unfortun, the optim solut to the abov problem is  intract as we can show by reduc from knapsack (we omit the complet proof). theorem 2 the problem of calcul the optim keyword  prune is np-hard. 2 given the intract of the optim solut, we need to resort to an approxim solut. a common approach for similar  knapsack problem is to adopt a greedi polici by keep the item with the maximum benefit per unit cost [9]. in our context, the potenti benefit of an invert list i(ti) is the number of queri that can be answer by ip when i(ti) is includ in ip . we approxim thi number by the fraction of queri in the queri load q that includ the term ti and repres it as p(ti). for  exampl, if 100 out of 1000 queri contain the term comput, algorithm 4.2 greedi keyword prune hs procedur (1) ∀ti, calcul hs(ti) = p (ti) |i(ti)| . (2) includ the invert list with the highest hs(ti) valu such that |ip | ≤ s · |if |. figur 6: approxim algorithm for the optim keyword prune. algorithm 4.3 global document prune v sg procedur (1) sort all document di base on pr(di) (2) find the threshold valu τp, such that onli s fraction of the document have pr(di) > τp (4) keep di in the invert list if pr(di) > τp figur 7: global document prune base on pr. then p(comput) = 0.1. the cost of includ i(ti) in the  pindex is it size |i(ti)|. thu, in our greedi approach in figur 6, we includ i(ti)"s in the decreas order of p(ti)/|i(ti)| as long as |ip | ≤ s · |if |. later in our experi section, we evalu what fraction of queri can be handl by ip when we emploi thi greedi keyword-prune polici. 4.3 document prune at a high level, document prune tri to take advantag of the observ that most user ar mainli interest in view the top few answer to a queri. given thi, it is unnecessari to keep all post in an invert list i(ti), becaus user will not look at most of the document in the list anywai. we depict the conceptu diagram of the document prune polici in figur 4. in the figur, we vertic prune post correspond to d4, d5 and d6 of t1 and d8 of t3, assum that these document ar unlik to be part of top-k answer to user queri. again, our goal is to develop a prune polici such that (1) we can comput the correct  indic function c from ip alon and (2) we can handl the largest fraction of queri with ip . in the next few section, we discuss a few altern approach for document prune. 4.3.1 global pr-base prune we first investig the prune polici that is commonli us by exist search engin. the basic idea for thi prune polici is that the queri-independ qualiti score pr(d) is a veri import factor in comput the final rank of the document (e.g.  pagerank is known to be on of the most import factor determin the overal rank in the search result), so we build the p-index by keep onli those document whose pr valu ar high (i.e., pr(d) > τp for a threshold valu τp). the hope is that most of the top-rank result ar like to have high pr(d) valu, so the answer comput from thi p-index is like to be similar to the  answer comput from the full index. figur 7 describ thi prune polici more formal, where we sort all document di"s by their respect pr(di) valu and keep a di in the p-index when it algorithm 4.4 local document prune v sl n: maximum size of a singl post list procedur (1) foreach i(ti) ∈ if (2) sort di"s in i(ti) base on pr(di) (3) if |i(ti)| ≤ n then keep all di"s (4) els keep the top-n di"s with the highest pr(di) figur 8: local document prune base on pr. algorithm 4.5 extend keyword-specif document prune procedur (1) for each i(ti) (2) keep d ∈ i(ti) if pr(d) > τpi or tr(d, ti) > τti figur 9: extend keyword-specif document prune base on pr and tr. pr(di) valu is higher than the global threshold valu τp. we refer to thi prune polici as global pr-base prune (gpr). variat of thi prune polici ar possibl. for exampl, we mai adjust the threshold valu τp local for each invert list i(ti), so that we maintain at least a certain number of post for each invert list i(ti). thi polici is shown in figur 8. we refer to thi prune polici as local pr-base prune (lpr).  unfortun, the biggest shortcom of thi polici is that we can prove that we cannot comput the correct function c from ip alon when ip is construct thi wai. theorem 3 no pr-base document prune can provid the result guarante. 2 proof assum we creat ip base on the gpr polici  (gener the proof to lpr is straightforward) and that everi  document d with pr(d) > τp is includ in ip . assum that the kth entri in the top-k result, ha a rank score of r(dk, q) = fr(tr(dk, q), pr(dk)). now consid anoth document dj that wa prune from ip becaus pr(dj) < τp. even so, it is still possibl that the document"s tr(dj, q) valu is veri high such that r(dj, q) = fr(tr(dj, q), pr(dj)) > r(dk, q). therefor, under a pr-base prune polici, the qualiti of the  answer comput from ip can be significantli wors than that from if and it is not possibl to detect thi degrad without  comput the answer from if . in the next section, we propos simpl yet essenti chang to thi prune polici that allow us to comput the correct function c from ip alon. 4.3.2 extend keyword-specif prune the main problem of global pr-base document prune  polici is that we do not know the term-relev score tr(d, ti) of the prune document, so a document not in ip mai have a higher rank score than the on return from ip becaus of their high tr score. here, we propos a new prune polici, call extend keyword-specif document prune (ek), which avoid thi  problem by prune not just base on the queri-independ pr(d) score but also base on the term-relev tr(d, ti) score. that is, for everi invert list i(ti), we pick two threshold valu, τpi for pr and τti for tr, such that if a document d ∈ i(ti) satisfi pr(d) > τpi or tr(d, ti) > τti, we includ it in i(ti) of ip . otherwis, we prune it from ip . figur 9 formal describ thi algorithm. the threshold valu, τpi and τti, mai be select in a number of differ wai. for exampl, if pr and tr have equal weight in the final rank and if we want to keep at most n  post in each invert list i(ti), we mai want to set the two  threshold valu equal to τi (τpi = τti = τi) and adjust τi such that n post remain in i(ti). thi new prune polici, when combin with a monoton  score function, enabl us to comput the correct indic  function c from the prune index. we us the follow exampl to explain how we mai comput c. exampl 4 consid the queri q = {t1, t2} and a monoton rank function, f(pr(d), tr(d, t1), tr(d, t2)). there ar three possibl scenario on how a document d appear in the prune index ip . 1. d appear in both i(t1) and i(t2) of ip : sinc complet inform of d appear in ip , we can comput the exact algorithm 4.6 comput answer from ip input queri q = {t1, . . . , tw} output a: top-k result, c: correct indic function procedur (1) for each di ∈ i(t1) ∪ · · · ∪ i(tw) (2) for each tm ∈ q (3) if di ∈ i(tm) (4) tr∗(di, tm) = tr(di, tm) (5) els (6) tr∗(di, tm) = τtm (7) f(di) = f(pr(di), tr∗(di, t1), . . . , tr∗(di, tn)) (8) a = top-k di"s with highest f(di) valu (9) c = j 1 if all di ∈ a appear in all i(ti), ti ∈ q 0 otherwis figur 10: rank base on threshold trτ (ti) and prτ (ti). score of d base on pr(d), tr(d, t1) and tr(d, t2) valu in ip : f(pr(d), tr(d, t1), tr(d, t2)). 2. d appear onli in i(t1) but not in i(t2): sinc d doe not appear in i(t2), we do not know tr(d, t2), so we  cannot comput it exact rank score. howev, from our prune criteria, we know that tr(d, t2) cannot be larger than the threshold valu τt2. therefor, from the  monoton of f (definit 2), we know that the rank score of d, f(pr(d), tr(d, t1), tr(d, t2)), cannot be larger than f(pr(d), tr(d, t1), τt2). 3. d doe not appear in ani list: sinc d doe not appear at all in ip , we do not know ani of the pr(d), tr(d, t1), tr(d, t2) valu. howev, from our prune criteria, we know that pr(d) ≤ τp1 and ≤ τp2 and that tr(d, t1) ≤ τt1 and tr(d, t2) ≤ τt2. therefor, from the monoton of f, we know that the rank score of d, cannot be larger than f(min(τp1, τp2), τt1, τt2). 2 the abov exampl show that when a document doe not appear in on of the invert list i(ti) with ti ∈ q, we cannot comput it exact rank score, but we can still comput it upper bound score by us the threshold valu τti for the miss valu. thi suggest the algorithm in figur 10 that comput the top-k result a from ip togeth with the correct indic function c. in the algorithm, the correct indic function c is set to on onli if all document in the top-k result a appear in all invert list i(ti) with ti ∈ q, so we know their exact score. in thi case, becaus these document have score higher than the upper bound score of ani other document, we know that no other document can appear in the top-k. the follow theorem formal prove the correct of the algorithm. in [11] fagin et al., provid a similar proof in the context of multimedia middlewar. theorem 4 given an invert index ip prune by the algorithm in figur 9, a queri q = {t1, . . . , tw} and a monoton rank function, the top-k result from ip comput by algorithm 4.6 is the same as the top-k result from if if c = 1. 2 proof let us assum dk is the kth rank document comput from ip accord to algorithm 4.6. for everi document di ∈ if that is not in the top-k result from ip , there ar two possibl scenario: first, di is not in the final answer becaus it wa prune from all invert list i(tj), 1 ≤ j ≤ w, in ip . in thi case, we know that pr(di) ≤ min1≤j≤wτpj < pr(dk) and that tr(di, tj) ≤ τtj < tr(dk, tj), 1 ≤ j ≤ w. from the monoton assumpt, it follow that the rank score of di is r(di) < r(dk). that is, di"s score can never be larger than that of dk. second, di is not in the answer becaus di is prune from some invert list, sai, i(t1), . . . , i(tm), in ip . let us assum ¯r(di) = f(pr(di),τt1,. . . ,τtm,tr(di, tm+1),. . . ,tr(di, tw)). then, from tr(di, tj) ≤ τtj(1 ≤ j ≤ m) and the monoton assumpt, 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 fractionofqueriesguarante−f(s) fraction of index − s fraction of queri guarante per fraction of index queri guarante figur 11: fraction of guarante queri f(s) answer in a keyword-prune p-index of size s. we know that r(di) ≤ ¯r(di). also, algorithm 4.6 set c = 1 onli when the top-k document have score larger than ¯r(di). therefor, r(di) cannot be larger than r(dk). 5. experiment evalu in order to perform realist test for our prune polici, we implement a search engin prototyp. for the experi in thi paper, our search engin index about 130 million page, crawl from the web dure march of 2004. the crawl start from the open directori"s [10] homepag and proceed in a breadth-first manner. overal, the total uncompress size of our crawl web page is approxim 1.9 tb, yield a full invert index if of approxim 1.2 tb. for the experi report in thi section we us a real set of queri issu to looksmart [22] on a daili basi dure april of 2003. after keep onli the queri contain keyword that were present in our invert index, we were left with a set of about 462 million queri. within our queri set, the averag number of term per queri is 2 and 98% of the queri contain at most 5 term. some experi requir us to us a particular rank  function. for these, we us the rank function similar to the on us in [20]. more precis, our rank function r(d, q) is r(d, q) = prnorm(d) + trnorm(d, q) (3) where prnorm(d) is the normal pagerank of d comput from the download page and trnorm(d, q) is the normal tf.idf cosin distanc of d to q. thi function is clearli simpler than the real function emploi by commerci search engin, but we believ for our evalu thi simpl function is adequ, becaus we ar not studi the effect of a rank function, but the effect of prune polici. 5.1 keyword prune in our first experi we studi the perform of the keyword prune, describ in section 4.2. more specif, we appli the algorithm hs of figur 6 to our full index if and creat a keyword-prune p-index ip of size s. for the construct of our keyword-prune p-index we us the queri frequenc observ dure the first 10 dai of our data set. then, us the remain 20-dai queri load, we measur f(s), the fraction of queri  handl by ip . accord to the algorithm of figur 5, a queri can be handl by ip (i.e., c = 1) if ip includ the invert list for all of the queri"s keyword. we have repeat the experi for vari valu of s,  pick the keyword greedili as discuss in section 4.2.the result is shown in figur 11. the horizont axi denot the size s of the p-index as a fraction of the size of if . the vertic axi show the fraction f(s) of the queri that the p-index of size s can answer. the result of figur 11, ar veri encourag: we can answer a signific fraction of the queri with a small fraction of the  origin index. for exampl, approxim 73% of the queri can be answer us 30% of the origin index. also, we find that when we us the keyword prune polici onli, the optim index size is s = 0.17. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 fractionofqueriesguarante-f(s) fraction of index - s fraction of queri guarante for top-20 per fraction of index fraction of queri guarante (ek) figur 12: fraction of guarante queri f(s) answer in a document-prune p-index of size s. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 fractionofqueriesansw index size - s fraction of queri answer for top-20 per fraction of index gpr lpr ek figur 13: fraction of queri answer in a document-prune p-index of size s. 5.2 document prune we continu our experiment evalu by studi the  perform of the variou document prune polici describ in  section 4.3. for the experi on document prune report here we work with a 5.5% sampl of the whole queri set. the reason behind thi is mere practic: sinc we have much less machin compar to a commerci search engin it would take us about a year of comput to process all 462 million queri. for our first experi, we gener a document-prune p-index of size s by us the extend keyword-specif prune (ek) in section 4. within the p-index we measur the fraction of queri that can be guarante (accord to theorem 4) to be correct. we have perform the experi for vari index size s and the result is shown in figur 12. base on thi figur, we can see that our document prune algorithm perform well across the scale of index size s: for all index size larger than 40%, we can guarante the correct answer for about 70% of the queri. thi impli that our ek algorithm can successfulli identifi the necessari  post for calcul the top-20 result for 70% of the queri by us at least 40% of the full index size. from the figur, we can see that the optim index size s = 0.20 when we us ek as our prune polici. we can compar the two prune scheme, name the keyword prune and ek, by contrast figur 11 and 12. our  observ is that, if we would have to pick on of the two prune polici, then the two polici seem to be more or less equival for the p-index size s ≤ 20%. for the p-index size s > 20%, keyword prune doe a much better job as it provid a higher number of guarante at ani given index size. later in section 5.3, we discuss the combin of the two polici. in our next experi, we ar interest in compar ek with the pr-base prune polici describ in section 4.3. to thi end, apart from ek, we also gener document-prune  pindex for the global pr-base prune (gpr) and the local  prbase prune (lpr) polici. for each of the polic we creat document-prune p-index of vari size s. sinc gpr and lpr cannot provid a correct guarante, we will compar the fraction of queri from each polici that ar ident (i.e. the same result in the same order) to the top-k result calcul from the full index. here, we will report our result for k = 20; the result ar similar for other valu of k. the result ar shown in figur 13. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 averagefractionofdocsinansw index size - s averag fraction of doc in answer for top-20 per fraction of index gpr lpr ek figur 14: averag fraction of the top-20 result of p-index with size s contain in top-20 result of the full index. fraction of queri guarante for top-20 per fraction of index, us keyword and document 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 keyword fraction of index - sh 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 document fraction of index - sv 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 fraction of queri guarante - f(s) figur 15: combin keyword and document prune. the horizont axi show the size s of the p-index; the vertic axi show the fraction f(s) of the queri whose top-20 result ar ident to the top-20 result of the full index, for a given size s. by observ figur 13, we can see that gpr perform the worst of the three polici. on the other hand ek, pick up earli, by answer a great fraction of queri (about 62%) correctli with onli 10% of the index size. the fraction of queri that lpr can answer remain below that of ek until about s = 37%. for ani index size larger than 37%, lpr perform the best. in the experi of figur 13, we appli the strict definit that the result of the p-index have to be in the same order as the on of the full index. howev, in a practic scenario, it mai be accept to have some of the result out of order. therefor, in our next experi we will measur the fraction of the result come from an p-index that ar contain within the result of the full index. the result of the experi is shown on figur 14. the horizont axi is, again, the size s of the p-index; the vertic axi show the averag fraction of the top-20 result common with the top-20 result from the full index. overal, figur 14 depict that ek and lpr identifi the same high (≈ 96%) fraction of result on averag for ani size s ≥ 30%, with gpr not too far behind. 5.3 combin keyword and document prune in section 5.1 and 5.2 we studi the individu perform of our keyword and document prune scheme. on interest question howev is how do these polici perform in  combin? what fraction of queri can we guarante if we appli both keyword and document prune in our full index if ? to answer thi question, we perform the follow experi. we start with the full index if and we appli keyword prune to creat an index ih p of size sh · 100% of if . after that, we further appli document prune to ih p , and creat our final  pindex ip of size sv ·100% of ih p . we then calcul the fraction of guarante queri in ip . we repeat the experi for differ valu of sh and sv. the result is shown on figur 15. the x-axi show the index size sh after appli keyword prune; the y-axi show the index size sv after appli document prune; the z-axi show the fraction of guarante queri after the two prune. for exampl the point (0.2, 0.3, 0.4) mean that if we appli keyword prune and keep 20% of if , and subsequ on the result index we appli document prune keep 30% (thu creat a  pindex of size 20%·30% = 6% of if ) we can guarante 40% of the queri. by observ figur 15, we can see that for p-index size smaller than 50%, our combin prune doe rel well. for exampl, by perform 40% keyword and 40% document prune (which translat to a prune index with s = 0.16) we can provid a guarante for about 60% of the queri. in figur 15, we also observ a plateau for sh > 0.5 and sv > 0.5. for thi combin prune polici, the optim index size is at s = 0.13, with sh = 0.46 and sv = 0.29. 6. relat work [3, 30] provid a good overview of invert index in web search engin and ir system. experiment studi and analys of variou partit scheme for an invert index ar present in [6, 23, 33]. the prune algorithm that we have present in thi paper ar independ of the partit scheme us. the work in [1, 5, 7, 20, 27] ar the most relat to our, as thei describ prune techniqu base on the idea of keep the  post that contribut the most in the final rank. howev, [1, 5, 7, 27] do not consid ani queri-independ qualiti (such as  pagerank) in the rank function. [32] present a gener framework for comput approxim top-k answer with some probabilist bound on the qualiti of result. our work essenti extend [1, 2, 4, 7, 20, 27, 31] by propos mechan for provid the correct guarante to the comput top-k result. search engin us variou method of cach as a mean of  reduc the cost associ with queri [18, 19, 21, 31]. thi thread of work is also orthogon to our becaus a cach scheme mai oper on top of our p-index in order to minim the answer  comput cost. the exact rank function emploi by current search engin ar close guard secret. in gener, howev, the rank ar base on queri-depend relev and  queryindepend document qualiti. queri-depend relev can be calcul in a varieti of wai (see [3, 30]). similarli, there ar a number of work that measur the qualiti of the document,  typic as captur through link-base analysi [17, 28, 26]. sinc our work doe not assum a particular form of rank function, it is complementari to thi bodi of work. there ha been a great bodi of work on top-k result calcul. the main idea is to either stop the travers of the invert list earli, or to shrink the list by prune post from the list [14, 4, 11, 8]. our proof for the correct indic function wa  primarili inspir by [12]. 7. conclud remark web search engin typic prune their larg-scale invert  index in order to scale to enorm queri load. while thi  approach mai improv perform, by comput the top result from a prune index we mai notic a signific degrad in the result qualiti. in thi paper, we provid a framework for new prune techniqu and answer comput algorithm that guarante that the top match page ar alwai place at the top of search result in the correct order. we studi two prune techniqu, name keyword-base and document-base prune as well as their combin. our experiment result demonstr that our algorithm can effect be us to prune an invert index without degrad in the qualiti of result. in particular, a keyword-prune index can guarante 73% of the queri with a size of 30% of the full index, while a document-prune index can  guarante 68% of the queri with the same size. when we combin the two prune algorithm we can guarante 60% of the queri with an index size of 16%. it is our hope that our work will help search engin develop better, faster and more effici index and thu provid for a better user search experi on the web. 8. refer [1] v. n. anh, o. de kretser, and a. moffat. vector-space rank with effect earli termin. in sigir, 2001. [2] v. n. anh and a. moffat. prune strategi for mix-mode queri. in cikm, 2006. [3] r. a. baeza-yate and b. a. ribeiro-neto. modern inform retriev. acm press / addison-weslei, 1999. [4] n. bruno, l. gravano, and a. marian. evalu top-k queri over web-access databas. in icd, 2002. [5] s. b¨uttcher and c. l. a. clark. a document-centric approach to static index prune in text retriev system. in cikm, 2006. [6] b. cahoon, k. s. mckinlei, and z. lu. evalu the perform of distribut architectur for inform retriev us a varieti of workload. acm toi, 18(1), 2000. [7] d. carmel, d. cohen, r. fagin, e. farchi, m. herscovici, y. maarek, and a. soffer. static index prune for inform retriev system. in sigir, 2001. [8] s. chaudhuri and l. gravano. optim queri over multimedia repositori. in sigmod, 1996. [9] t. h. cormen, c. e. leiserson, and r. l. rivest. introduct to algorithm, 2nd edit. mit press/mcgraw hill, 2001. [10] open directori. http://www.dmoz.org. [11] r. fagin. combin fuzzi inform: an overview. in sigmod record, 31(2), 2002. [12] r. fagin, a. lotem, and m. naor. optim aggreg algorithm for middlewar. in pod, 2001. [13] a. gulli and a. signorini. the index web is more than 11.5 billion page. in www, 2005. [14] u. guntzer, g. balk, and w. kiessl. toward effici multi-featur queri in heterogen environ. in itcc, 2001. [15] z. gy¨ongyi, h. garcia-molina, and j. pedersen. combat web spam with trustrank. in vldb, 2004. [16] b. j. jansen and a. spink. an analysi of web document retriev and view. in intern conf. on internet comput, 2003. [17] j. kleinberg. authorit sourc in a hyperlink environ. journal of the acm, 46(5):604-632, septemb 1999. [18] r. lempel and s. moran. predict cach and prefetch of queri result in search engin. in www, 2003. [19] r. lempel and s. moran. optim result prefetch in web search engin with segment indic. acm tran. inter. tech., 4(1), 2004. [20] x. long and t. suel. optim queri execut in larg search engin with global page order. in vldb, 2003. [21] x. long and t. suel. three-level cach for effici queri process in larg web search engin. in www, 2005. [22] looksmart inc. http://www.looksmart.com. [23] s. melnik, s. raghavan, b. yang, and h. garcia-molina. build a distribut full-text index for the web. acm toi, 19(3):217-241, 2001. [24] a. ntoula, j. cho, c. olston. what"s new on the web? the evolut of the web from a search engin perspect. in www, 2004. [25] a. ntoula, m. najork, m. manass, and d. fetterli. detect spam web page through content analysi. in www, 2006. [26] l. page, s. brin, r. motwani, and t. winograd. the pagerank citat rank: bring order to the web. technic report, stanford univers. [27] m. persin, j. zobel, and r. sack-davi. filter document retriev with frequenc-sort index. journal of the american societi of inform scienc, 47(10), 1996. [28] m. richardson and p. domingo. the intellig surfer: probabilist combin of link and content inform in pagerank. in advanc in neural inform process system, 2002. [29] s. robertson and k. sp¨arck-jone. relev weight of search term. journal of the american societi for inform scienc, 27:129-46, 1976. [30] g. salton and m. j. mcgill. introduct to modern inform retriev. mcgraw-hill, first edit, 1983. [31] p. c. saraiva, e. s. de moura, n. ziviani, w. meira, r. fonseca, and b. riberio-neto. rank-preserv two-level cach for scalabl search engin. in sigir, 2001. [32] m. theobald, g. weikum, and r. schenkel. top-k queri evalu with probabilist guarante. in vldb, 2004. [33] a. tomas and h. garcia-molina. perform of invert indic in share-noth distribut text document inform retriev system. in parallel and distribut inform system, 1993. 