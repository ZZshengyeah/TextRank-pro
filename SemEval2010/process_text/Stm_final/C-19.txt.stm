servic interfac: a new abstract for implement and compos protocol∗ olivi r¨utti pawł t. wojciechowski andr´e schiper ecol polytechniqu f´ed´eral de lausann (epfl) 1015 lausann, switzerland {olivi.rutti, pawel.wojciechowski, andr.schiper}@epfl.ch abstract in thi paper we compar two approach to the design of protocol framework - tool for implement modular  network protocol. the most common approach us event as the main abstract for a local interact between  protocol modul. we argu that an altern approach, that is base on servic abstract, is more suitabl for  express modular protocol. it also facilit advanc featur in the design of protocol, such as dynam updat of  distribut protocol. we then describ an experiment  implement of a servic-base protocol framework in java. categori and subject descriptor c.2.4 [comput-commun network]:  distribut applic 1. introduct protocol framework, such cactu [5, 2], appia [1, 16], ensembl [12, 17], eva [3], sdl [8] and neko[6, 20], ar  program tool for develop modular network protocol. thei allow complex protocol to be implement by  decompos them into sever modul cooper togeth. thi approach facilit code reus and custom of distribut protocol in order to fit the need of differ applic. moreov, protocol modul can be plug in to the system dynam. all these featur of protocol framework make them an interest enabl technolog for implement adapt system [14] - an import class of applic. most protocol framework ar base on event (all  framework cite abov ar base on thi abstract). event ar us for asynchron commun between differ modul on the same machin. howev, the us of event rais some problem [4, 13]. for instanc, the composit of modul mai requir connector to rout event, which introduc burden for a protocol compos [4]. protocol framework such as appia and eva extend the event-base approach with channel. howev, in our opinion, thi  solut is not satisfactori sinc composit of complex  protocol stack becom more difficult. in thi paper, we propos a new approach for  build modular protocol, that is base on a servic  abstract. we compar thi new approach with the common, event-base approach. we show that protocol framework base on servic have sever advantag, e.g. allow for a fairli straightforward protocol composit, clear  implement, and better support of dynam replac of distribut protocol. to valid our claim, we have  implement samoa - an experiment protocol framework that is pure base on the servic-base approach to modul composit and implement. the framework allow us to compar the servic- and event-base implement of an adapt group commun middlewar. the paper is organ as follow. section 2 defin  gener notion. section 3 present the main characterist of event-base framework, and featur that ar distinct for each framework. section 4 describ our new approach, which is base on servic abstract. section 5 discuss the advantag of a servic-base protocol framework compar to an event-base protocol framework. the descript of our experiment implement is present in section 6. final, we conclud in section 7. 2. protocol framework in thi section, we describ notion that ar common to all protocol framework. protocol and protocol modul. a protocol is a  distribut algorithm that solv a specif problem in a  distribut system, e.g. a tcp protocol solv the reliabl channel problem. a protocol is implement as a set of ident protocol modul locat on differ machin. protocol stack. a stack is a set of protocol modul (of differ protocol) that ar locat on the same machin. note that, despit it name, a stack is not strictli layer, 691 i.e. a protocol modul can interact with all other  protocol modul in the same stack, not onli with the protocol modul directli abov and below. in the remaind of thi paper, we us the term machin and stack interchang. stack 1 s1 q1 r1 p1 network figur 1: exampl of a protocol stack in figur 1, we show an exampl protocol stack. we  repres protocol modul by capit letter index with a natur number, e.g. p1, q1, r1 and s1. we write pi to denot the protocol modul of a protocol p in stack i. we us thi notat throughout the paper. modul ar  repres as white box. arrow show modul interact. for instanc, protocol modul p1 interact with the protocol modul q1 and convers (see fig. 1). protocol modul interact. below, we defin the  differ kind of interact between protocol modul. • request ar issu by protocol modul. a request by a protocol modul pi is an asynchron call by pi of anoth protocol modul. • repli ar the result of a request. a singl request can gener sever repli. onli protocol modul belong to the same protocol as the modul that ha issu the request ar concern by the correspond repli. for exampl, a request by pi gener repli that concern onli protocol modul pj. • notif can be us by a protocol modul to inform (possibl mani) protocol modul in the same stack about the occurr of a specif event.  notif mai also be the result of a request. 3. event-base protocol  framework design most exist protocol framework ar event-base.  exampl ar cactu [5, 2], appia [1, 16] and ensembl [12, 17]. in thi section, we defin the notion of an event in  protocol framework. we also explain how protocol modul ar structur in event-base framework. event. an event is a special object for indirect  commun between protocol modul in the same stack. event mai transport some inform, e.g. a network messag or some other data. with event, the commun is  indirect, i.e. a protocol modul that trigger an event is not awar of the modul(s) that handl the event. event  enabl on-to-mani commun within a protocol stack. trigger an event can be done either synchron or asynchron. in the former case, the thread that trigger an event e is block until all protocol modul that handl e have termin handl of event e. in the latter case, the thread that trigger the event is not block. protocol modul. in event-base protocol framework, a protocol modul consist of a set of handler. each handler is dedic to handl of a specif event. handler of the same protocol modul mai share data. handler can be  dynam bound to event. handler can also be unbound dynam. upon trigger some event e, all handler bound to e ar execut. if no handler is bound, the  behavior is usual unspecifi. stack 1 p1 q1 r1 s1 network f e gg deliv send h figur 2: exampl of an event-base protocol stack in figur 2, we show an exampl of an event-base stack. event ar repres by small letter, e.g. e, f, ... the fact that a protocol modul can trigger an event is repres by an arrow start from the modul. a white trapezoid insid a modul box repres a handler defin by the protocol modul. to mark that some handler is bound to event e, we us an arrow point to the handler (the label on the arrow repres the event e). for exampl, the protocol modul p1 trigger event e and handl event f (see fig. 2). note that the network is repres as a special protocol modul that handl the send event (to send a messag to anoth machin) and trigger the deliv event (upon receipt of a messag from anoth machin). specif featur. some protocol framework have uniqu featur. below, we present the featur that influenc  composit and implement of protocol modul. in cactu [5, 2], the programm can give a prioriti  number to a handler upon bind it to an event. when an event is trigger, all handler ar execut follow the order of prioriti. a handler h is also abl to cancel the execut of an event trigger: all handler that should be execut after h accord to the prioriti ar not execut. appia [1, 16] and eva [3] introduc the notion of channel. channel allow to build rout of event in protocol stack. each protocol modul ha to subscrib to on or mani  channel. all event ar trigger by specifi a channel thei belong to. when a protocol modul trigger an event e  specifi channel c, all handler bound to e that ar part of a protocol that subscrib to c ar execut (in the order  prescrib by the definit of channel c). 4. servic-base protocol  framework in thi section, we describ our new approach for  implement and compos protocol that is base on servic. 692 we show in section 5 the advantag of servic-base  protocol framework over event-base protocol framework. servic interfac. in our servic-base framework,  protocol modul in the same stack commun through object call servic interfac. request, repli and notif ar all issu to servic interfac. protocol modul. a protocol modul is a set of execut, listen and interceptor. execut handl request. an execut can be  dynam bound to a servic interfac. it can be later unbound. a request issu to a servic interfac si lead to the  execut of the execut bound to si. if no execut is bound to si, the request is delai until some execut is bound to si. contrari to event, at most on execut at ani time can be bound to a servic interfac on everi machin. listen handl repli and notif. a listen can be dynam bound and unbound to/from a servic  interfac si. a notif issu to a servic interfac si is handl by all listen bound to si in the local stack. a repli issu to a servic interfac is handl by on singl listen. to ensur that on singl listen handl a repli, a modul pi ha to identifi, each time it issu a request, the listen to handl the possibl repli. if the request and the repli occur respect, in stack i and in stack j, the servic interfac si on i commun to the servic interfac si on j the listen that must handl the repli. if the listen that must handl the repli doe not exist, the repli is delai until the listen is creat. stack 1 p1 q1 r1 s1 network t u nt figur 3: exampl of a servic-base protocol stack in figur 3, we show an exampl of a servic-base stack. we denot a servic interfac by a small letter (e.g. t, u and nt) in a hexagon box. the fact that a modul pi can gener a request to a servic interfac si is repres by a dash black arrow go from pi to si. similarli, a dash white arrow go from modul pi to servic  interfac si repres the fact that pi can gener a repli or a notif to si. we repres execut with white box insid protocol modul and listen with white box with a grai border. a connect line between a servic interfac si and an execut e (resp. a listen l) show that e (resp. l) is bound to si. in figur 3, modul q1 contain an execut bound to servic interfac t and a listen bound to servic interfac u. modul q1 can gener repli and notif to servic interfac t and request to servic interfac u. note that the servic interfac nt allow to access the network. p1 q1 p1 q1 t1t1 t t t figur 4: execut of protocol interact with interceptor an interceptor plai a special rˆol. similarli to execut, interceptor can be dynam bound or unbound to a  servic interfac. thei ar activ each time a request, a repli or a notif is issu to the servic interfac thei ar bound to. thi is illustr in figur 4. in the right part of the figur, the interceptor of the protocol modul t1 is repres by a round box. the interceptor is bound to servic interfac t. the left part of the figur show that an interceptor can be seen as an execut plu a listen. when p1 issu a request req to the servic interfac t, the execut-interceptor of t1 is execut. then, modul t1 mai forward a request req to the servic interfac t, where we can have req = req 1 . when modul q1 issu a repli or a notif, a similar mechan is us, except that thi time the listen-interceptor of t1 is execut. note that a protocol modul ti, that ha an interceptor bound to a servic interfac, is abl to modifi request, repli and notif. upon request, if sever interceptor ar bound to the same servic interfac, thei ar execut in the order of bind. upon repli and notif, the order is  revers. 5. advantag of servic-base protocol framework design we show in thi section the advantag of servic-base protocol framework over event-base protocol framework. we structur our discuss in three part. firstli, we present how protocol interact ar model in each of the protocol framework. then, we discuss the composit of protocol modul in each of these framework. final, we present the problem of dynam protocol replac and the advantag of servic interfac in order to implement it. the discuss is summar in tabl 1. 5.1 protocol modul interact a natur model of protocol interact (as present in section 2) facilit the implement of protocol  modul. for each protocol interact, we show how it is  model in both framework. we also explain that an inadequ model mai lead to problem. request. in servic-base framework, a request is  gener to a servic interfac. each request is handl by at most on execut, sinc we allow onli on execut to be bound to a servic interfac at ani time. on the other hand, in event-base framework, a protocol modul  emul a request by trigger an event. there is no guarante 1 the two servic interfac t in the left part of figur 4 repres the same servic interfac t. the duplic is onli to make the figur readabl. 693 that thi event is bound to onli on handler, which mai lead to program error. repli. when a protocol modul gener a repli in a servic-base framework, onli the correct listen  (identifi at the time the correspond request wa issu) is execut. thi ensur that a request issu by some  protocol modul qi, lead to repli handl by protocol modul qj (i.e. protocol modul of the same protocol). thi is not the case in event-base framework, as we now show. consid protocol modul q1 in figur 2 that  trigger event g to emul a request. modul s1 handl the request. when modul si trigger event h to emul a  repli (rememb that a repli can occur in mani stack), both modul qi and ri will handl the repli (thei both contain a handler bound to h). thi behavior is not correct: onli protocol modul qi should handl the repli. moreov, as modul ri ar not necessarili implement to interact with modul qi, thi behavior mai lead to error. solut to solv thi problem exist. howev, thei  introduc an unnecessari burden on the protocol programm and the stack compos. for instanc, channel allow to rout event to ensur that modul handl onli event  concern them. howev, the protocol programm must take channel into account when implement protocol.  moreov, the composit of complex stack becom more  difficult due to the fact that the compos ha to creat mani channel to ensur that modul handl event correctli. an addit of special protocol modul (name connector) for rout event is also not satisfactori, sinc it requir  addit work from the compos and introduc overhead. notif. contrari to request and repli,  notif ar well model in event-base framework. the reason is that notif correspond to the on-to-mani commun scheme provid by event. in servic-base framework, notif ar also well model. when a modul gener a notif to a servic interfac si, all listen bound to s ar execut. note that in thi case,  servic interfac provid the same pattern of commun as event. 5.2 protocol modul composit repli (and sometim notif) ar the result of a request. thu, there is a semant link between them. the compos of protocol modul must preserv thi link in order to compos correct stack. we explain now that servic base framework provid a mechan to preserv thi link, while in event-base framework, the lack of such mechan lead to error-prone composit. in servic-base framework, request, repli and  notif ar issu to a servic interfac. thu, a servic interfac introduc a link between these interact. to compos a correct stack, the compos ha to bound a  listen to servic interfac si for each modul that issu a request to si. the same must be done for on execut that is part of a modul that issu repli or notif.  appli thi simpl methodolog ensur that everi request issu to a servic interfac si eventu result in sever repli or notif issu to the same servic interfac si. in event-base framework, all protocol interact ar issu through differ event: there is no explicit link  between an event trigger upon request and an event  trigger upon the correspond repli. thu, the compos of a protocol stack must know the mean of each event in order to preserv the semant link between repli (and  notif) and request. moreov, noth prevent from bind a handler that should handl a request to an event us to issu a repli. note that these problem can be  partial solv by type event and handler. howev, it doe not prevent from error if there ar sever instanc of the same event type. note that protocol composit is clearer in the  protocol framework that ar base on servic, rather than on event. the reason is that sever event that ar us to model differ protocol interact can be model by a singl servic interfac. 5.3 dynam replac of protocol dynam replac of protocol consist in switch on-the-fly between protocol that solv the same problem. replac of a protocol p by a new protocol newp mean that a protocol modul pi is replac by newpi in everi stack i. thi replac is problemat sinc the local  replac (within stack) must be synchron in order to guarante protocol correct [21, 18]. q1 q1 r1 p1 1p 1newp 1 repl−p1 repl−p1 r newp1 gg h h" g" t figur 5: dynam replac of protocol p for the synchron algorithm to work, modul  interact ar intercept in order to detect a time when pi should be replac by newpi. (other solut, e.g. in [11], ar more complex.) in fig. 5, we show how thi intercept can be implement in protocol framework that ar base on servic (in the left part of the figur) and event (in the right part of the figur). the two-side arrow point to the protocol modul p1 and newp1 that ar switch. it can be seen that the approach that us the servic  interfac mechan ha advantag. the intercept  modul repl-p1 ha an interceptor bound to servic interfac t that intercept everi request handl by modul p1 and all repli and notif issu by p1. the code of the modul p1 can therefor remain unchang. in event-base framework, the solut is to add an  intermedi modul repl-p1 that intercept the request issu to p1 and also the repli and notif issu by p1.  although thi ad-hoc solut mai seem similar to the  servicebas approach, there is an import differ. the  eventbas solut requir to slightli modifi the modul p1 sinc instead of handl event g and trigger event h, p1 must now handl differ event g" and h" (see fig. 5). 6. implement we have implement an experiment servic-base  protocol framework (call samoa) [7]. our implement is light-weight: it consist of approxim 1200 line of code in java 1.5 (with gener). in thi section, we describ the main two class of our  implement: servic (encod the servic interfac) and 694 servic-base event-base protocol interact an adequ an inadequ represent represent protocol composit clear and safe complex and error-prone dynam replac an integr ad-hoc solut mechan tabl 1: servic-base vs. event-base protocol (encod protocol modul). final, we present an exampl protocol stack that we have implement to  valid the servic-base approach. the servic class. a servic object is character by the argument of request and the argument of respons. a respons is either a repli or a notif. a special  argument, call messag, determin the kind of interact model by the respons. a messag repres a piec of inform sent over the network. when a protocol modul issu a request, it can give a messag as an argument. the messag can specifi the listen that must handl the repli. when a protocol modul issu a respons to a servic  interfac, a repli is issu if on of the argument of the respons is a messag specifi a listen. otherwis, a notif is issu. execut, listen and interceptor ar encod as  innerclass of the servic class. thi allow to provid type-safe protocol interact. for instanc, execut can onli be bound to the servic object, thei belong to. thu, the paramet pass to request (that ar verifi static) alwai correspond to the paramet accept by the  correspond execut. the type of a servic object is determin by the type of the argument of request and respons. a servic object t is compat with anoth servic object s if the type of the argument of request (and respons) of t is a subtyp of the argument of request (and respons) of s. in practic, if a protocol modul pi can issu a request to a protocol udp, then it mai also issu a request to tcp (compat with udp) due to the subtyp relat on paramet of commun modul. the protocol class. a protocol object consist of three set of compon, on set for each compon type (a  listen, an execut, and an interceptor). protocol object ar character by name to retriev them easili.  moreov, we have ad some featur to bind and unbind all execut or interceptor to/from the correspond servic object. protocol object can be load to a stack  dynam. all these featur made it easi to implement dynam replac of network protocol. protocol stack implement. to valid our idea, we have develop an adapt group commun (agc) middlewar, adopt both the servic- and the event-base approach. fig. 6 show the correspond stack of the agc middlewar. both stack allow the consensu and atom broadcast protocol to be dynam updat. the architectur of our middlewar, shown in fig. 6, build on the group commun stack describ in [15]. the udp and rp2p modul provid respect,  unreli and reliabl point-to-point transport. the fd modul implement a failur detector; we assum that it ensur the stack 1 udp1rp2p1 repl ct1 1abc. repl ct1 abc.1 network fd1 gm1 rp2p nt udp d f abcast consensu stack 1 repl ct1 1abc. repl abc.1 udp1 fd1 rp2p1 ct1 network 1gm send deliv figur 6: adapt group commun  middlewar: servic-base (left) vs. event-base (right) properti of the 3s failur detector [9]. the ct modul provid a distribut consensu servic us the  chandratoueg algorithm [10]. the abc. modul implement atom broadcast - a group commun primit that deliv messag to all process in the same order. the gm  modul provid a group membership servic that maintain  consist membership data among group member (see [19] for detail). the repl abc. and the repl ct modul  implement the replac algorithm [18] for, respect, the abc. and the ct protocol modul. note that each arrow in the event-base architectur repres an event. we do not name event in the figur for readabl. the left stack in figur 6 show the implement of agc with our servic-base framework. the right stack show the same implement with an event-base  framework. perform evalu. to evalu the overhead of  servic interfac, we compar perform of the  serviceand event-base implement of the agc middlewar. the latter implement of agc us the cactu protocol framework [5, 2]. in our experi, we compar the averag latenc of atom broadcast (abcast), which is defin as follow. consid a messag m sent us abcast. we denot by ti(m) the time between the moment of send m and the moment of deliv m on a machin (stack) i. we  defin the averag latenc of m as the averag of ti(m) for all machin (stack) i within a group of stack. perform test have been made us a cluster of pc run red hat linux 7.2, where each pc ha a pentium iii 766 mhz processor and 128mb of ram. all pc ar  interconnect by a 100 base-tx duplex ethernet hub. our experi ha involv 7 machin (stack) that abcast messag of 4mb under a constant load, where a load is a number of messag per second. in figur 7, we show the result of our experi for differ load. latenc ar shown on the vertic axi, while messag load ar shown on the horizont axi. the solid line show the result  obtain with our servic-base framework. the dash line show the result obtain with the cactu framework. the 695 0 500 1000 1500 2000 10 20 30 40 50 60 70 80 90 100 averagelat[ms] load [msg/s] servic-base framework cactu figur 7: comparison between our servic-base framework and cactu overhead of the servic-base framework is approxim 10%. thi can be explain as follow. firstli, the  servicebas framework provid a higher level abstract, which ha a small cost. secondli, the agc middlewar wa  initi implement and optim for the event-base  cactu framework. howev, it is possibl to optim the agc middlewar for the servic-base framework. 7. conclus in the paper, we propos a new approach to the protocol composit that is base on the notion of servic interfac, instead of event. we believ that the servic-base  framework ha sever advantag over event-base framework. it allow us to: (1) model accur protocol interact, (2) reduc the risk of error dure the composit phase, and (3) simpli implement dynam protocol updat. a prototyp implement allow us to valid our idea. 8. refer [1] the appia project. document avail electron at http://appia.di.fc.ul.pt/. [2] nina t. bhatti, matti a. hiltunen, richard d. schlicht, and wanda chiu. coyot: a system for construct fine-grain configur commun servic. acm transact on comput system, 16(4):321-366, novemb 1998. [3] francisco vilar brasileiro, fab´ıola greve, freder tronel, michel hurfin, and jean-pierr le narzul. eva: an event-base framework for develop special commun protocol. in proceed of the 1st ieee intern symposium on network comput and applic (nca "01), 2001. [4] daniel c. b¨unzli, sergio mena, and uw nestmann. protocol composit framework. a header-driven model. in proceed of the 4th ieee intern symposium on network comput and applic (nca "05), juli 2005. [5] the cactu project. document avail electron at http://www.cs.arizona.edu/ cactu/. [6] the neko project. document avail electron at http://lsrwww.epfl.ch/neko/. [7] the samoa project. document avail electron at http://lsrwww.epfl.ch/samoa/. [8] the sdl project. document avail electron at http://www.sdl-forum.org/sdl/. [9] tushar deepak chandra, vasso hadzilaco, and sam toueg. the weakest failur detector for solv consensu. journal of the acm, 43(4):685-722, 1996. [10] tushar deepak chandra and sam toueg. unreli failur detector for reliabl distribut system. journal of the acm, 43(2):225-267, 1996. [11] wen-ke chen, matti a. hiltunen, and richard d. schlicht. construct adapt softwar in distribut system. in proceed of the 21st ieee intern confer on distribut comput system (icdc "01), april 2001. [12] the ensembl project. document avail electron at http://www.cs.cornel.edu/info/ project/ensembl/. [13] richard ekwal, sergio mena, stefan pleisch, and andr´e schiper. toward flexibl finit-state-machin-base protocol composit. in proceed of the 3rd ieee intern symposium on network comput and applic (nca "04), august 2004. [14] philip k. mckinlei, sei masoud sadjadi, eric p. kasten, and betti h.c. cheng. compos adapt softwar. ieee comput, 37(7):56-64, 2004. [15] sergio mena, andr´e schiper, and pawel t. wojciechowski. a step toward a new gener of group commun system. in proceed of the 4th acm/ifip/usenix intern middlewar confer (middlewar "03), lnc 2672, june 2003. [16] hugo miranda, alexandr pinto, and lu´ıs rodrigu. appia, a flexibl protocol kernel support multipl coordin channel. in proceed of the 21st ieee intern confer on distribut comput system (icdc "01), april 2001. [17] ohad rodeh, kenneth p. birman, mark hayden, zhen xiao, and danni dolev. the architectur and perform of secur protocol in the ensembl group commun system. technic report tr-98-1703, comput scienc depart, cornel univers, septemb 1998. [18] olivi r¨utti, pawel t. wojciechowski, and andr´e schiper. dynam updat of distribut agreement protocol. tr ic-2005-12, school of comput and commun scienc, ecol polytechniqu f´ed´eral de lausann (epfl), march 2005. [19] andr´e schiper. dynam group commun. technic report ic-2003-27, school of comput and commun scienc, ecol polytechniqu f´ed´eral de lausann (epfl), april 2003. to appear in acm distribut comput. [20] p´eter urb´an, xavier d´efago, and andr´e schiper. neko: a singl environ to simul and prototyp distribut algorithm. in proceed of the 15th intern confer on inform network (icoin "01), februari 2001. [21] pawel t. wojciechowski and olivi r¨utti. on correct of dynam protocol updat. in proceed of the 7th ifip confer on formal method for open object-base distribut system (fmood "05), lnc 3535. springer, june 2005. 696 