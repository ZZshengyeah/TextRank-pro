self-adapt applic on the grid gosia wrzesinska jason maassen henri e. bal dept. of comput system, vrije universiteit amsterdam {gosia, jason, bal}@cs.vu.nl abstract grid ar inher heterogen and dynam. on import problem in grid comput is resourc select, that is, find an appropri resourc set for the applic. anoth problem is adapt to the chang characterist of the grid  environ. exist solut to these two problem requir that a  perform model for an applic is known. howev,  construct such model is a complex task. in thi paper, we investig an approach that doe not requir perform model. we start an applic on ani set of resourc. dure the applic run, we period collect the statist about the applic run and  deduc applic requir from these statist. then, we adjust the resourc set to better fit the applic need. thi approach  allow us to avoid perform bottleneck, such as overload wan link or veri slow processor, and therefor can yield signific perform improv. we evalu our approach in a number of scenario typic for the grid. categori and subject descriptor c.2.4 [comput  commun network]: distribut system-distribut applic ; c.4 [perform of system]: measur  techniqu, model techniqu gener term algorithm, measur, perform,  experiment 1. introduct in recent year, grid comput ha becom a real altern to  tradit parallel comput. a grid provid much comput power, and thu offer the possibl to solv veri larg problem, especi if applic can run on multipl site at the same time (7; 15; 20). howev, the complex of grid environ also is mani time larger than that of tradit parallel machin like cluster and supercomput. on import problem is resourc select - select a set of comput node such that the  applic achiev good perform. even in tradit,  homogen parallel environ, find the optim number of node is a hard problem and is often solv in a trial-and-error fashion. in a grid environ thi problem is even more difficult, becaus of the heterogen of resourc: the comput node have variou speed and the qualiti of network connect between them vari from low-latenc and high-bandwidth local-area network (lan) to high-latenc and possibl low-bandwidth wide-area network (wan). anoth import problem is that the perform and avail of grid resourc vari over time: the network link or comput node mai becom overload, or the comput node mai becom unavail becaus of crash or becaus thei have been claim by a higher prioriti applic. also, new, better resourc mai becom avail. to maintain a reason perform level, the applic therefor need to adapt to the chang condit. the adapt problem can be reduc to the resourc select problem: the resourc select phase can be repeat dure  applic execut, either at regular interv, or when a perform problem is detect, or when new resourc becom avail. thi approach ha been adopt by a number of system (5; 14; 18). for resourc select, the applic runtim is estim for some resourc set and the set that yield the shortest runtim is select for execut. predict the applic runtim on a given set of resourc, howev, requir knowledg about the applic.  typic, an analyt perform model is us, but construct such a model is inher difficult and requir an expertis which applic programm mai not have. in thi paper, we introduc and evalu an altern approach to applic adapt and resourc select which doe not need a perform model. we start an applic on ani set of resourc. dure the applic run, we period collect  inform about the commun time and idl time of the  processor. we us these statist to automat estim the resourc requir of the applic. next, we adjust the resourc set the applic is run on by ad or remov comput node or even entir cluster. our adapt strategi us the work by eager et al. (10) to determin the effici and tri to keep the effici of the applic between a lower and upper threshold deriv from their theori. processor ar ad or delet to stai between the threshold, thu adapt automat to the  chang environ. a major advantag of our approach is that it improv  applic perform in mani differ situat that ar typic for grid comput. it handl all of the follow case: • automat adapt the number of processor to the degre of parallel in the applic, even when thi degre chang dynam dure the comput • migrat (part of) a comput awai from overload  resourc • remov resourc with poor commun link that slow down the comput • ad new resourc to replac resourc that have crash our work assum the applic is malleabl and can run  (effici) on multipl site of a grid (i.e., us co-alloc (15)). it should not us static load balanc or be veri sensit to  wide121 area latenc. we have appli our idea to divid-and-conquer applic, which satisfi these requir. divid-and-conquer ha been shown to be an attract paradigm for program grid applic (4; 20). we believ that our approach can be extend to other class of applic with the given assumpt. we implement our strategi in satin, which is a java-centric framework for write grid-enabl divid-and-conquer  applic (20). we evalu the perform of our approach on the da-2 wide-area system and we will show that our approach yield major perform improv (roughli 10-60 %) in the abov scenario. the rest of thi paper is structur as follow. in section 2, we explain what assumpt we ar make about the applic and grid resourc. in section 3, we present our resourc select and adapt strategi. in section 4, we describ it implement in the satin framework. in section 5, we evalu our approach in a number of grid scenario. in section 6, we compar our approach with the relat work. final, in section 7, we conclud and  describ futur work. 2. background and assumpt in thi section, we describ our assumpt about the applic and their resourc. we assum the follow resourc model. the applic ar run on multipl site at the same time, where site ar cluster or supercomput. we also assum that the  processor of the site ar access us a grid schedul system, such as koala (15), zorilla (9) or grm (3). processor  belong to on site ar connect by a fast lan with a low latenc and high bandwidth. the differ site ar connect by a wan. commun between site suffer from high latenc. we  assum that the link connect the site with the internet backbon might becom bottleneck caus the inter-site commun to suffer from low bandwidth. we studi the adapt problem in the context of  divid-andconqu applic. howev, we believ that our methodolog can be us for other type of applic as well. in thi section we summar the assumpt about applic that ar  import to our approach. the first assumpt we make is that the applic is  malleabl, i.e., it is abl to handl processor join and leav the on-go comput. in (23), we show how  divid-andconqu applic can be made fault toler and malleabl. processor can be ad or remov at ani point in the  comput with littl overhead. the second assumpt is that the  applic can effici run on processor with differ speed. thi can be achiev by us a dynam load balanc  strategi, such as work steal us by divid-and-conquer  applic (19). also, master-worker applic typic us dynam load-balanc strategi (e.g., mw - a framework for write  griden master-worker applic (12)). we find it a reason assumpt for a grid applic, sinc applic for which the slowest processor becom a bottleneck will not be abl to  effici util grid resourc. final, the applic should be  insensit to wide-area latenc, so it can run effici on a  widearea grid (16; 17). 3. self-adapt in thi section we will explain how we us applic  malleabl to find a suitabl set of resourc for a given applic and to adapt to chang condit in the grid environ. in order to monitor the applic perform and guid the adapt, we ad an extra process to the comput which we call  adapt coordin. the adapt coordin period collect perform statist from the applic processor. we  introduc a new applic perform metric: weight averag  effici which describ the applic perform on a  heterogen set of resourc. the coordin us statist from  applic processor to comput the weight averag effici. if the effici fall abov or below certain threshold, the  coordin decid on ad or remov processor. a heurist formula is us to decid which processor have to be remov. dure thi process the coordin learn the applic requir by rememb the characterist of the remov processor. these requir ar then us to guid the ad of new processor. 3.1 weight averag effici in tradit parallel comput, a standard metric describ the perform of a parallel applic is effici. effici is defin as the averag util of the processor, that is, the fraction of time the processor spend do us work rather than be idl or commun with other processor (10). effici = 1 n ∗ n i=0 (1 − overheadi ) where n is the number of processor and overheadi is the  fraction of time the ith processor spend be idl or commun. effici indic the benefit of us multipl processor. typic, the effici drop as new processor ar ad to the comput. therefor, achiev a high speedup (and thu a low execut time) and achiev a high system util ar conflict goal (10). the optim number of processor is the number for which the ratio of effici to execut time is  maxim. ad processor beyond thi number yield littl benefit. thi number is typic hard to find, but in (10) it wa  theoret proven that if the optim number of processor is us, the effici is at least 50%. therefor, ad processor when  effici is smaller or equal to 50% will onli decreas the system util without signific perform gain. for heterogen environ with differ processor speed, we extend the notion of effici and introduc weight  averag effici. wa effici = 1 n ∗ n i=0 speedi ∗ (1 − overheadi ) the us work done by a processor (1 − overheadi) is weight by multipli it by the speed of thi processor  rel to the fastest processor. the fastest processor ha speed = 1, for other hold: 0 < speed ≤ 1. therefor, slower processor ar model as fast on that spend a larg fraction of the time be idl. weight averag effici reflect the fact that ad slow processor yield less benefit than ad fast processor. in the heterogen world, it is hardli benefici to add  processor if the effici is lower than 50% unless the ad processor is faster than some of the current us processor. ad faster processor might be benefici regardless of the effici. 3.2 applic monitor each processor measur the time it spend commun or  be idl. the comput is divid into monitor period.  after each monitor period, the processor comput their overhead over thi period as the percentag of the time thei spent be idl or commun in thi period. apart from total overhead, each processor also comput the overhead of inter-cluster and  intraclust commun. to calcul weight averag effici, we need to know the rel speed of the processor, which depend on the  applic and the problem size us. sinc it is impract to run the 122 whole applic on each processor separ, we us  applicationspecif benchmark. current we us the same applic with a small problem size as a benchmark and we requir the applic programm to specifi thi problem size. thi approach requir extra effort from the programm to find the right problem size and possibl to produc input file for thi problem size, which mai be hard. in the futur, we ar plan to gener benchmark  automat by choos a random subset of the task graph of the origin applic. benchmark have to be re-run period becaus the speed of a processor might chang if it becom overload by anoth  applic (for time-share machin). there is a trade-off between the accuraci of speed measur and the overhead it incur. the longer the benchmark, the greater the accuraci of the measur. the more often it is run, the faster chang in processor speed ar detect. in our current implement, the applic  programm specifi the length of the benchmark (by specifi it  problem size) and the maxim overhead it is allow to caus.  processor run the benchmark at such frequenc so as not to exce the specifi overhead. in the futur, we plan to combin  benchmark with monitor the load of the processor which would allow us to avoid run the benchmark if no chang in processor load is detect. thi optim will further reduc the benchmark overhead. note that the benchmark overhead could be avoid  complet for more regular applic, for exampl, for  masterwork applic with task of equal or similar size. the  processor speed could then be measur by count the task  process by thi processor within on monitor period.  unfortun, divid-and-conquer applic typic exhibit a veri  irregular structur. the size of task can vari by mani order of magnitud. at the end of each monitor period, the processor send the overhead statist and processor speed to the coordin.  period, the coordin comput the weight averag effici and other statist, such as averag inter-cluster overhead or overhead in each cluster. the clock of the processor ar not synchron with each other or with the clock of the coordin. each  processor decid separ when it is time to send data. occasion, the coordin mai miss data at the end of a monitor period, so it ha to us data from the previou monitor period for these processor. thi caus small inaccuraci in the calcul of the coordin, but doe not influenc the perform of adapt. 3.3 adapt strategi the adapt coordin tri to keep the weight averag  effici between emin and emax. when it exce emax, the  coordin request new processor from the schedul. the number of request processor depend on the current effici: the higher the effici, the more processor ar request. the coordin start remov processor when the weight averag effici drop below emin. the number of node that ar remov again depend on the weight averag effici. the lower the  effici, the more node ar remov. the threshold we us ar emax = 50%, becaus we know that ad processor when  effici is lower doe not make sens, and emin = 30%.  effici of 30% or lower might indic perform problem such as low bandwidth or overload processor. in that case,  remov bad processor will be benefici for the applic. such low effici might also indic that we simpli have too mani  processor. in that case, remov some processor mai not be benefici but it will not harm the applic. the coordin alwai tri to remov the worst processor. the bad of a processor is determin by the follow formula: proc badnessi = α ∗ 1 speedi + β ∗ ic overheadi + γ ∗ inw orstclust(i) the processor is consid bad if it ha low speed ( 1 speed is big) and high inter-cluster overhead (ic overhead). high  interclust overhead indic that the bandwidth to thi processor"s cluster is insuffici. remov processor locat in a singl cluster is desir sinc it decreas the amount of wide-area commun. therefor, processor belong to the worst cluster ar prefer. function inw orstclust(i) return 1 for processor belong to the worst cluster and 0 otherwis. the bad of cluster is comput similarli to the bad of processor: cluster badnessi = α ∗ 1 speedi + β ∗ ic overheadi the speed of a cluster is the sum of processor speed normal to the speed of the fastest cluster. the ic overhead of a cluster is an averag of processor inter-cluster overhead. the α, β and γ coeffici determin the rel import of the term. those coeffici ar establish empir. current we ar us the follow valu: α = 1, β = 100 and γ = 10, base on the observ that ic overhead > 0.2 indic bandwidth problem and processor with speed < 0.05 do not contribut to the comput. addition, when on of the cluster ha an exception high inter-cluster overhead (larger than 0.25), we conclud that the  bandwidth on the link between thi cluster and the internet backbon is insuffici for the applic. in that case, we simpli remov the whole cluster instead of comput node bad and remov the worst node. after decid which node ar remov, the  coordin send a messag to these node and the node leav the comput. figur 1 show a schemat view of the adapt strategi. dash line indic a part that is not support yet, as will be explain below. thi simpl adapt strategi allow us to improv applic perform in sever situat typic for the grid: • if an applic is start on fewer processor than it degre of parallel allow, it will automat expand to more  processor (as soon as there ar extra resourc avail). convers, if an applic is start on more processor than it can  effici us, a part of the processor will be releas. • if an applic is run on an appropri set of resourc but after a while some of the resourc (processor and/or  network link) becom overload and slow down the  comput, the overload resourc will be remov. after remov the overload resourc, the weight averag effici will increas to abov the emax threshold and the adapt  coordin will try to add new resourc. therefor, the applic will be migrat from overload resourc. • if some of the origin resourc chosen by the user ar  inappropri for the applic, for exampl the bandwidth to on of the cluster is too small, the inappropri resourc will be remov. if necessari, the adapt compon will try to add other resourc. • if dure the comput a substanti part of the processor will crash, the adapt compon will try to add new  resourc to replac the crash processor. 123 0 2000 4000 6000 runtim(sec.) scenario 0 a b c scenario 1 scenario 2 scenario 3 scenario 4 scenario 5 without monitor and adapt (runtim 1) with monitor and adapt (runtim 2) with monitor but no adapt (runtim 3) figur 2. the runtim of the barn-hut applic, scenario 0-5 add node faster node avail if comput weight averag effici e wa wait & collect statist rank node remov worst node wae ewa y n n y abov if below if emin max figur 1. adapt strategi • if the applic degre of parallel is chang dure the comput, the number of node the applic is run on will be automat adjust. further improv ar possibl, but requir extra  function from the grid schedul and/or integr with monitor servic such as nw (22). for exampl, ad node to a  comput can be improv. current, we add ani node the  schedul give us. howev, it would be more effici to ask for the fastest processor among the avail on. thi could be done, for exampl, by pass a benchmark to the grid schedul, so that it can measur processor speed in an applic specif wai.  typic, it would be enough to measur the speed of on processor per site, sinc cluster and supercomput ar usual  homogen. an altern approach would be rank the processor base on paramet such as clock speed and cach size. thi  approach is sometim us for resourc select for sequenti  applic (14). howev, it is less accur than us an  applic specif benchmark. also, dure applic execut, we can learn some  applic requir and pass them to the schedul. on exampl is minim bandwidth requir by the applic. the lower bound on minim requir bandwidth is tighten each time a cluster with high inter-cluster overhead is remov. the bandwidth  between each pair of cluster is estim dure the comput by measur data transfer time, and the bandwidth to the remov cluster is set as a minimum. altern, inform from a grid monitor system can be us. such bound can be pass to the schedul to avoid ad inappropri resourc. it is especi import when migrat from resourc that caus perform problem: we have to be care not to add the resourc we have just remov. current we us blacklist - we simpli do not  allow ad resourc we remov befor. thi mean, howev, that we cannot us these resourc even if the caus of the  perform problem disappear, e.g. the bandwidth of a link might improv if the background traffic diminish. we ar current not abl to perform opportunist migrat - migrat to better resourc when thei ar discov. if an applic run with effici between emin and emax, the adapt compon will not undertak ani action, even if  better resourc becom avail. enabl opportunist migrat requir, again, the abil to specifi to the schedul what  better resourc ar (faster, with a certain minim bandwidth) and receiv notif when such resourc becom avail. exist grid schedul such as gram from the globu toolkit (11) do not support such function. the develop of the koala metaschedul (15) have recent start a project whose goal is to provid support for adapt applic. we ar current discuss with them the possibl of provid the function requir by us, aim to extend our adapt  strat124 egi to support opportunist migrat and to improv the initi resourc select. 4. implement we incorpor our adapt mechan into satin - a java framework for creat grid-enabl divid-and-conquer  applic. with satin, the programm annot the sequenti code with divid-and-conquer primit and compil the annot code with a special satin compil that gener the necessari commun and load balanc code. satin us a veri  effici, grid-awar load balanc algorithm - cluster-awar  random work steal (cr) (19), which hide wide-area latenc by overlap local and remot steal. satin also provid  transpar fault toler and malleabl (23). with satin, remov and ad processor from/to an ongo comput incur littl overhead. we instrument the satin runtim system to collect runtim statist and send them to the adapt coordin. the  coordin is implement as a separ process. both coordin and satin ar implement entir in java on top of the ibi  commun librari (21). the core of ibi is also implement in java. the result system therefor is highli portabl (due to java"s write onc, run anywher properti) allow the softwar to run unmodifi on a heterogen grid. ibi also provid the ibi registri. the registri provid, among other, a membership servic to the processor take part in the comput. the adapt coordin us the registri to discov the applic process, and the applic process us thi servic to discov each other. the registri also offer fault detect (addit to the fault detect provid by the  commun channel). final, the registri provid the possibl to send signal to applic process. the coordin us thi function to notifi the processor that thei need to leav the comput. current the registri is implement as a  central server. for request new node, the zorilla (9) system is us - a peer-to-peer supercomput middlewar which allow  straightforward alloc of processor in multipl cluster and/or  supercomput. zorilla provid local-awar schedul, which tri to alloc processor that ar locat close to each other in term of commun latenc. in the futur, zorilla will also support bandwidth-awar schedul, which tri to maxim the total bandwidth in the system. zorilla can be easili replac with  anoth grid schedul. in the futur, we ar plan to integr our adapt compon with gat (3) which is becom a  standard in the grid commun and koala (15) a schedul that  provid co-alloc on top of standard grid middlewar, such as the globu toolkit (11). 5. perform evalu in thi section, we will evalu our approach. we will demonstr the perform of our mechan in a few scenario. the first scenario is an ideal situat: the applic run on a  reason set of node (i.e., such that the effici is around 50%) and no problem such as overload network and processor,  crash processor etc. occur. thi scenario allow us to measur the overhead of the adapt support. the remain scenario ar typic for grid environ and demonstr that with our  adapt support the applic can avoid seriou perform  bottleneck such as overload processor or network link. for each  scenario, we compar the perform of an applic with  adapt support to a non-adapt version. in the non-adapt version, the coordin doe not collect statist and no benchmark (for measur processor speed) is perform. in the ideal scenario, 0 5 10 15 iter number 0 200 400 600 iterationdur(sec.) start on 8 node start on 16 node start on 24 node start on 8 node start on 16 node start on 24 node }no adapt }with adapt figur 3. barn-hut iter durat with/without adapt, too few processor 0 5 10 15 iter number 0 200 400 600 800 1000 iterationdur(sec.) no adapt with adapt cpu load introduc overload node remov start ad node 36 node reach figur 4. barn-hut iter durat with/without adapt, overload cpu we addition measur the perform of an applic with collect statist and benchmark turn on but without  do adapt, that is, without allow it to chang the number of node. thi allow us to measur the overhead of benchmark and collect statist. in all experi we us a monitor period of 3 minut for the adapt version of the applic. all the experi were carri out on the da-2 wide-area  system (8), which consist of five cluster locat at five dutch  uni125 versiti. on of the cluster consist of 72 node, the other of 32 node. each node contain two 1 ghz pentium processor. within a cluster, the node ar connect by fast ethernet. the cluster ar connect by the dutch univers internet backbon. in our experi, we us the barn-hut n-bodi simul.  barneshut simul the evolut of a larg set of bodi under influenc of (gravit or electrostat) forc. the evolut of n bodi is simul in iter of discret time step. 5.1 scenario 0: adapt overhead in thi scenario, the applic is start on 36 node. the node ar equal divid over 3 cluster (12 node in each cluster). on thi number of node, the applic run with 50% effici, so we consid it a reason number of node. as mention abov, in thi scenario we measur three runtim: the runtim of the  applic without adapt support (runtim 1), the runtim with adapt support (runtim 2) and the runtim with monitor (i.e., collect of statist and benchmark) turn on but  without allow it to chang the number of node (runtim 3). those runtim ar shown in figur 2, first group of bar. the comparison between runtim 3 and 1 show the overhead of adapt support. in thi experi it is around 15%. almost all overhead come from benchmark. the benchmark is run 1-2 time per  monitor period. thi overhead can be made smaller by increas the length of the monitor period and decreas the benchmark frequenc. the monitor period we us (3 minut) is rel short, becaus the runtim of the applic wa also rel short (30-60 minut). us longer run applic would not allow us to finish the experiment in a reason time. howev, real-world grid applic typic need hour, dai or even week to complet. for such applic, a much longer  monitor period can be us and the adapt overhead can be kept much lower. for exampl, with the barn-hut applic, if the monitor period is extend to 10 minut, the overhead drop to 6%. note that combin benchmark with monitor processor load (as describ in section 3.2) would reduc the benchmark overhead to almost zero: sinc the processor load is not chang, the benchmark would onli need to be run at the begin of the comput. 5.2 scenario 1: expand to more node in thi scenario, the applic is start on fewer node than the applic can effici us. thi mai happen becaus the user doe not know the right number of node or becaus insuffici node were avail at the moment the applic wa start. we tri 3 initi number of node: 8 (scenario 1a), 16 (scenario 1b) and 24 (scenario 1c). the node were locat in 1 or 2 cluster. in each of the three sub-scenario, the applic gradual expand to 36-40 node locat in 4 cluster. thi allow to reduc the applic runtim by 50% (scenario 1a), 35% (scenario 1b) and 12% (scenario 1c) with respect to the non-adapt version. those runtim ar shown in figur 2. sinc barn-hut is an iter applic, we also measur the time of each iter, as shown in figur 3. adapt reduc the iter time by a factor of 3 (scenario 1a), 1.7 (scenario 1b) and 1.2 (scenario 1c) which allow us to conclud that the gain in the total runtim would be even bigger if the applic were run longer than for 15 iter. 5.3 scenario 2: overload processor in thi scenario, we start the applic on 36 node in 3 cluster. after 200 second, we introduc a heavi, artifici load on the  processor in on of the cluster. such a situat mai happen when an applic with a higher prioriti is start on some of the  resourc. figur 4 show the iter durat of both the adapt and non-adapt version. after introduc the load, the iter 0 5 10 15 iter number 0 200 400 600 800 1000 iterationdur(sec.) no adapt with adapt on cluster is badli connect badli connect cluster remov start ad node 36 node reach figur 5. barn-hut iter durat with/without adapt, overload network link 0 5 10 15 iter number 0 200 400 600 800 1000 iterationdur(sec.) no adapt with adapt on cluster is badli connect 12 node lightli overload remov badli connect cluster remov 2 lightli overload node figur 6. barn-hut iter durat with/without adapt, overload cpu and an overload network link durat increas by a factor of 2 to 3. also, the iter time becam veri variabl. the adapt version react by remov the overload node. after remov these node, the weight averag effici rose to around 35% which trigger ad new node and the applic expand back to 38 node. so, the  overload node were replac by better node, which brought the  iter durat back to the initi valu. thi reduc the total runtim by 14%. the runtim ar shown in figur 2. 126 5.4 scenario 3: overload network link in thi scenario, we ran the applic on 36 node in 3 cluster. we simul that the uplink to on of the cluster wa overload and the bandwidth on thi uplink wa reduc to approxim 100 kb/s. to simul low bandwidth we us the traffic-shape techniqu describ in (6). the iter durat in thi  experi ar shown in figur 5. the iter durat of the  nonadapt version exhibit enorm variat: from 170 to 890  second. the adapt version remov the badli connect cluster after the first monitor period. as a result, the weight  averag effici rose to around 35% and new node were gradual ad until their number reach 38. thi brought the iter time down to around 100 second. the total runtim wa reduc by 60% (figur 2). 5.5 scenario 4: overload processor and an overload network link in thi scenario, we ran the applic on 36 node in 3 cluster. again, we simul an overload uplink to on of the cluster. addition, we simul processor with heterogen speed by insert a rel light artifici load on the processor in on of the remain cluster. the iter durat ar shown in  figur 6. again, the non-adapt version exhibit a great variat in iter durat: from 200 to 1150 second. the adapt  version remov the badli connect cluster after the first monitor period which bring the iter durat down to 210 second on averag. after remov on of the cluster, sinc some of the  processor ar slower (approxim 5 time), the weight averag effici rais onli to around 40%. sinc thi valu li between emin and emax, no node ar ad or remov. thi exampl  illustr what the advantag of opportunist migrat would be. there were faster node avail in the system. if these node were ad to the applic (which could trigger remov the slower node) the iter durat could be reduc even further. still, the adapt reduc the total runtim by 30% (figur 2). 5.6 scenario 5: crash node in the last scenario, we also run the applic on 36 node in 3 cluster. after 500 second, 2 out of 3 cluster crash. the iter durat ar shown in figur 7. after the crash, the iter durat rais from 100 to 200 second. the weight effici rose to around 30% which trigger ad new node in the adapt version. the number of node gradual went back to 35 which brought the iter durat back to around 100 second. the total runtim wa reduc by 13% (figur 2). 6. relat work a number of grid project address the question of resourc  select and adapt. in grad (18) and assist (1), resourc  select and adapt requir a perform model that allow predict applic runtim. in the resourc select phase, a number of possibl resourc set is examin and the set of  resourc with the shortest predict runtim is select. if  perform degrad is detect dure the comput, the resourc select phase is repeat. grad us the ratio of the predict execut time (of certain applic phase) to the real  execut time as an indic of applic perform. assist us the number of iter per time unit (for iter applic) or the number of task per time unit (for regular master-worker applic) as a perform indic. the main differ  between these approach and our approach is the us of perform model. the main advantag is that onc the perform model is known, the system is abl to take more accur migrat  decis than with our approach. howev, even if the perform 0 5 10 15 iter number 0 200 400 600 800 1000 iterationdur(sec.) no adapt with adapt 2 out of 3 cluster crash start ad node 36 node reach figur 7. barn-hut iter durat with/without adapt, crash cpu model is known, the problem of find an optim resourc set (i.e. the resourc set with the minim execut time) is np-complet. current, both grad and assist examin onli a subset of all possibl resourc set and therefor there is no guarante that the result resourc set will be optim. as the number of avail grid resourc increas, the accuraci of thi approach diminish, as the subset of possibl resourc set that can be examin in a reason time becom smaller. anoth disadvantag of these system is that the perform degrad detect is suitabl onli for iter or regular applic. cactu (2) and gridwai (14) do not us perform model. howev, these framework ar onli suitabl for sequenti  (gridwai) or singl-site applic (cactu). in that case, the resourc select problem boil down to select the fastest machin or cluster. processor clock speed, averag load and a number of  processor in a cluster (cactu) ar us to rank resourc and the  resourc with the highest rank is select. the applic is migrat if perform degrad is detect or better resourc ar  discov. both cactu and gridwai us the number of iter per time unit as the perform indic. the main limit of thi methodolog is that it is suitabl onli for sequenti or singl-site applic. moreov, resourc select base on clock speed is not alwai accur. final, perform degrad detect is suitabl onli for iter applic and cannot be us for  irregular comput such as search and optim problem. the resourc select problem wa also studi by the appl project (5). in the context of thi project, a number of applic were studi and perform model for these applic were creat. base on such a model a schedul agent is built that us the perform model to select the best resourc set and the best applic schedul on thi set. appl schedul agent ar written on a case-by-case basi and cannot be reus for anoth  applic. two reusabl templat were also develop for specif class of applic, name master-worker (amwat templat) and paramet sweep (apst templat) applic. migrat is not support by the appl softwar. 127 in (13), the problem of schedul master-worker applic is studi. the author assum homogen processor (i.e., with the same speed) and do not take commun cost into account. therefor, the problem is reduc to find the right number of worker. the approach here is similar to our in that no  perform model is us. instead, the system tri to deduc the  applic requir at runtim and adjust the number of worker to approach the ideal number. 7. conclus and futur work in thi paper, we investig the problem of resourc select and adapt in grid environ. exist approach to these  problem typic assum the exist of a perform model that allow predict applic runtim on variou set of resourc. howev, creat perform model is inher difficult and requir knowledg about the applic. we propos an approach that doe not requir in-depth knowledg about the applic. we start the applic on an arbitrari set of resourc and monitor it perform. the perform monitor allow us to learn certain applic requir such as the number of processor need by the applic or the applic"s bandwidth  requir. we us thi knowledg to gradual refin the resourc set by remov inadequ node or ad new node if necessari. thi approach doe not result in the optim resourc set, but in a reason resourc set, i.e. a set free from variou perform bottleneck such as slow network connect or overload  processor. our approach also allow the applic to adapt to the chang grid condit. the adapt decis ar base on the weight averag  effici - an extens of the concept of parallel effici defin for tradit, homogen parallel machin. if the weight  averag effici drop below a certain level, the adapt  coordin start remov worst node. the bad of the node is defin by a heurist formula. if the weight averag effici rais abov a certain level, new node ar ad. our simpl  adapt strategi allow us to handl multipl scenario typic for grid environ: expand to more node or shrink to fewer node if the applic wa start on an inappropri number of  processor, remov inadequ node and replac them with better on, replac crash processor, etc. the applic adapt fulli  automat to chang condit. we implement our approach in the satin divid-and-conquer framework and evalu it on the da-2 distribut supercomput and demonstr that our  approach can yield signific perform improv (up to 60% in our experi). futur work will involv extend our adapt strategi to support opportunist migrat. thi, howev, requir grid schedul with more sophist function than current  exist. further research is also need to decreas the benchmark overhead. for exampl, the inform about cpu load could be us to decreas the benchmark frequenc. anoth line of research that we wish to investig is us feedback control to refin the adapt strategi dure the applic run. for  exampl, the node bad formula could be refin at runtim base on the effect of the previou adapt decis. final, the central implement of the adapt coordin might becom a bottleneck for applic which ar run on veri larg number of node (hundr or thousand). thi problem can be solv by implement a hierarchi of coordin: on  subcoordin per cluster which collect and process statist from it cluster and on main coordin which collect the inform from the sub-coordin. acknowledg thi work wa carri out in the context of virtual laboratori for e-scienc project (ww.vl-e.nl). thi project is support by a bsik grant from the dutch ministri of educ, cultur and scienc (oc&w) and is part of the ict innov program of the ministri of econom affair (ez). refer [1] m. aldinucci, f. andr, j. buisson, s. campa, m. coppola, m. danelutto, and c. zoccolo. parallel program/compon adapt manag. in parco 2005, sept. 2005. [2] g. allen, d. angulo, i. foster, g. lanfermann, c. liu, t. radk, e. seidel, and j. shalf. the cactu worm:  experi with resourc discoveri and alloc in a grid  environ. int"l journal of high perform comput  applic, 15(4):345-358, 2001. [3] g. allen, k. davi, k. n. dolka, n. d. doulami, t. goodal, t. kielmann, a. merzki, j. nabrzyski, j. pukacki, t. radk, m. russel, e. seidel, j. shalf, and i. taylor. enabl  applic on the grid - a gridlab overview. int"l journal of high-perform comput applic, 17(4):449-466, aug. 2003. [4] j. e. baldeschwiel, r. d. blumof, and e. a. brewer.  atla: an infrastructur for global comput. in 7th acm sigop european workshop on system support for  worldwid applic, page 165-172, sept. 1996. [5] f. berman, r. wolski, h. casanova, w. cirn, h. dail, m. faerman, s. figueira, j. hay, g. obertelli, j. schopf, g. shao, s. smallen, n. spring, a. su, and d.  zagorodnov. adapt comput on the grid us appl. ieee tran. on parallel and distribut system, 14(4):369-382, apr. 2003. [6] d.-m. chiu, m. kadanski, j. provino, and j. weslei.  experi in program a traffic shaper. in 5th ieee symp. on comput and commun, page 470-476, 2000. [7] w. chrabakh and r. wolski. gridsat: a chaff-base  distribut sat solver for the grid. in 2003 acm/ieee  confer on supercomput, page 37, 2003. [8] the distribut asci supercomput (da). http://www.cs.vu.nl/da2/. [9] n. drost, r. v. van nieuwport, and h. e. bal. simpl  localityawar co-alloc in peer-to-peer supercomput. in 6th int"l workshop on global peer-2-peer comput, mai 2005. [10] d. l. eager, j. zahorjan, and e. d. lazowska. speedup versu effici in parallel system. ieee transact on comput, 38(3):408-423, mar. 1989. [11] i. foster. globu toolkit version 4: softwar for  serviceori system. in ifip intern confer on  network and parallel comput, page 2-13. springer-verlag lnc 3779, 2005. [12] j.-p. goux, s. kulkarni, m. yoder, and j. linderoth. an enabl framework for master-worker applic on the comput grid. in 9th ieee int"l symp. on high  perform distribut comput, page 43-50, aug. 2000. [13] e. heymann, m. a. senar, e. luqu, and m. livni.  adapt schedul for master-worker applic on the  comput grid. in 1st ieee/acm intern workshop on grid comput, page 214-227. springer verlag lnc 1971, 2000. 128 [14] e. huedo, r. s. montero, and i. m. llorent. a framework for adapt execut in grid. softwar - practic &  experi, 34(7):631-651, 2004. [15] h. h. moham and d. h. epema. experi with the koala co-alloc schedul in multiclust. in 5th ieee/acm int"l symp. on cluster comput and the grid, page 640-650, mai 2005. [16] a. plaat, h. e. bal, and r. f. h. hofman. sensit of parallel applic to larg differ in bandwidth and latenc in two-layer interconnect. in 5th int"l symp. on high perform comput architectur, page 244-253, jan. 1999. [17] j. w. romein, h. e. bal, j. schaeffer, and a. plaat. a  perform analysi of transposit-tabl-driven work schedul in distribut search. ieee tran. on parallel and distribut system, 13(5):447-459, mai 2002. [18] s. s. vadhiyar and j. j. dongarra. self adapt in grid comput. concurr and comput: practic and experi, 17(2-4):235-257, 2005. [19] r. v. van nieuwpoort, t. kielmann, and h. e. bal. effici load balanc for wide-area divid-and-conquer applic. in 8th acm sigplan symp. on principl and practic of parallel program, page 34-43, 2001. [20] r. v. van nieuwpoort, j. maassen, t. kielmann, and h. e. bal. satin: simpl and effici java-base grid program. scalabl comput: practic and experi, 6(3):19-32, sept. 2004. [21] r. v. van nieuwpoort, j. maassen, g. wrzesinska, r.  hofman, c. jacob, t. kielmann, and h. e. bal. ibi: a  flexibl and effici java-base grid program environ. concurr & comput: practic & experi,  17(78):1079-1107, 2005. [22] r. wolski, n. spring, and j. hay. the network weather  servic: a distribut resourc perform forecast servic for metacomput. journal of futur gener comput system, 15(5-6):757-768, oct. 1999. [23] g. wrzesinska, r. v. van nieuwport, j. maassen, and h. e. bal. fault-toler, malleabl and migrat for  divideand-conquer applic on the grid. in int"l parallel and distribut process symposium, apr. 2005. 129 